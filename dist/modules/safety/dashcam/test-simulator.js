// Â© 2025 City Pave. All Rights Reserved. Unauthorized copying is prohibited.
import { initializeDashCam } from './dashcam.js'; export class DashcamSimulator { constructor() { this.log = []; this.stepDelay = 1000; this.mockStream = { getTracks: () => [{ stop: () => console.log("[Sim] Stream track stopped") }] }; const origError = console.error; console.error = (...args) => { this.logToScreen(`[App Error] ${args.join(' ')}`, "red"); origError.apply(console, args); }; const origAlert = window.alert; window.alert = (msg) => { this.logToScreen(`[App Alert] ${msg}`, "orange"); console.log(`[App Alert] ${msg}`); }; } async run() { console.clear(); console.log("%cðŸš— Dashcam Simulation Initiated", "color: #00ff00; font-weight: bold; font-size: 14px;"); this.setupMocks(); try { await this.step(1, "Initialize Module", () => { if (!document.getElementById('start-dashcam-btn')) throw new Error("UI not found"); }); await this.step(2, "Start Recording", async () => { const startBtn = document.getElementById('start-dashcam-btn'); startBtn.click(); let attempts = 0; while (attempts < 10) { const activeUi = document.getElementById('dashcam-ui-active'); if (!activeUi.classList.contains('hidden')) return; await new Promise(r => setTimeout(r, 200)); attempts++; } throw new Error("Active UI didn't appear after 2 seconds"); }); await this.step(3, "Fill Buffer (Stress Test)", async () => { this.logToScreen("[Sim] Fast-forwarding buffer filling...", "gray"); await new Promise(r => setTimeout(r, 4000)); }); await this.step(4, "Trigger Incident", async () => { const triggerBtn = document.getElementById('trigger-incident-btn'); triggerBtn.click(); await new Promise(r => setTimeout(r, 1500)); if (triggerBtn.disabled) throw new Error("Button stuck in disabled state"); }); await this.step(5, "Simulate Cleanup/Stop", async () => { const stopBtn = document.getElementById('stop-dashcam-btn'); stopBtn.click(); const startUi = document.getElementById('dashcam-ui-start'); if (startUi.classList.contains('hidden')) throw new Error("Start UI didn't return"); }); this.logToScreen("âœ… Simulation Completed Successfully", "green"); console.log("%câœ… Simulation Completed Successfully", "color: #00ff00; font-weight: bold; font-size: 16px;"); } catch (error) { this.logToScreen("âŒ Simulation Failed: " + error.message, "red"); console.error("%câŒ Simulation Failed: " + error.message, "color: red; font-weight: bold;"); } } async step(num, name, action) { this.logToScreen(`Step ${num}: ${name}...`, "black"); console.log(`%cStep ${num}: ${name}...`, "color: yellow;"); await action(); this.logToScreen(`Step ${num}: PASS`, "green"); console.log(`%cStep ${num}: PASS`, "color: cyan;"); await new Promise(r => setTimeout(r, this.stepDelay)); } logToScreen(msg, color) { const output = document.getElementById('sim-output'); if (output) { const line = document.createElement('div'); line.textContent = msg; line.style.color = color; line.style.fontFamily = 'monospace'; output.appendChild(line); output.scrollTop = output.scrollHeight; } } setupMocks() { const self = this; const realGetElementById = document.getElementById.bind(document); document.getElementById = (id) => { const el = realGetElementById(id); if (id === 'dashcam-preview' && el) { return new Proxy(el, { set(target, prop, value) { if (prop === 'srcObject') { console.log("[Sim] Trapped srcObject assignment to mock stream"); return true; } target[prop] = value; return true; } }); } return el; }; if (!navigator.mediaDevices) navigator.mediaDevices = {}; navigator.mediaDevices.getUserMedia = async () => { console.log("[Sim] Mock getUserMedia called"); return this.mockStream; }; window.MediaRecorder = class MockMediaRecorder { constructor(stream, options) { console.log("[Sim] Mock MediaRecorder created", options); this.state = 'inactive'; this.ondataavailable = null; this.timer = null; } start(timeslice) { this.state = 'recording'; console.log(`[Sim] Recorder started with ${timeslice}ms timeslice`); this.timer = setInterval(() => { if (this.ondataavailable) { const blob = new Blob(["test-video-data"], { type: "video/webm" }); this.ondataavailable({ data: blob }); } }, 100); } stop() { this.state = 'inactive'; console.log("[Sim] Recorder stopped"); clearInterval(this.timer); } static isTypeSupported() { return true; } }; const originalServices = window.firebaseServices || {}; window.firebaseServices = { ...originalServices, auth: { currentUser: { uid: 'sim_user', displayName: 'Sim Driver' } }, uploadBytes: async (ref, blob) => { const size = blob.size; const bufferWorking = size <= 380; if (bufferWorking) { self.logToScreen(`[Sim] Buffer Check: OK (Size: ${size} bytes, capped at ~24 chunks)`, "green"); } else { self.logToScreen(`[Sim] Buffer Check: FAILED (Size: ${size} bytes). Old chunks not dropped!`, "red"); } return { ref: ref }; }, getDownloadURL: async () => "http: addDoc: async (collection, data) => { console.log("[Sim] Mock addDoc called", data); return { id: "mock_doc_id" }; }, ref: () => ({}), collection: () => ({}) }; } }