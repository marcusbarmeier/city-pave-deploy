// Â© 2025 City Pave. All Rights Reserved. Unauthorized copying is prohibited.
export class ShiftAggregator { constructor(firebaseServices) { this.services = firebaseServices; this.db = firebaseServices.db; this.collection = firebaseServices.collection; this.query = firebaseServices.query; this.where = firebaseServices.where; this.getDocs = firebaseServices.getDocs; } async getShiftData(userId, dateString) { if (!userId || !dateString) throw new Error("Missing userId or dateString"); const startOfDay = new Date(dateString + 'T00:00:00'); const endOfDay = new Date(dateString + 'T23:59:59.999'); const startISO = startOfDay.toISOString(); const endISO = endOfDay.toISOString(); console.log(`[ShiftAggregator] Fetching for User: ${userId}, Date: ${dateString}`); console.log(`[ShiftAggregator] TimeRange: ${startISO} -> ${endISO}`); try { const [timeLogs, tickets, forms, routes, dispatch, dashcam] = await Promise.all([ this.fetchTimeLogs(userId, startISO, endISO), this.fetchTickets(userId, dateString), this.fetchForms(userId, startISO, endISO), this.fetchRoutes(userId, startISO, endISO), this.fetchDispatch(userId, dateString), this.fetchDashcamClips(userId, startISO, endISO) ]); return { date: dateString, userId: userId, dispatch: dispatch, assets: { timeLogs, tickets, forms, routes, dashcam }, summary: this.calculateSummary(timeLogs, tickets, routes) }; } catch (error) { console.error("Error aggregating shift data:", error); throw error; } } async fetchTimeLogs(userId, startISO, endISO) { const q = this.query( this.collection(this.db, "time_logs"), this.where("userId", "==", userId), this.where("startTime", ">=", startISO), this.where("startTime", "<=", endISO) ); const snap = await this.getDocs(q); return snap.docs.map(doc => ({ id: doc.id, ...doc.data() })); } async fetchTickets(userId, dateString) { const q = this.query( this.collection(this.db, "time_tickets"), this.where("userId", "==", userId), this.where("date", "==", dateString) ); const snap = await this.getDocs(q); return snap.docs.map(doc => ({ id: doc.id, ...doc.data() })); } async fetchForms(userId, startISO, endISO) { const q = this.query( this.collection(this.db, "form_submissions"), this.where("userId", "==", userId), this.where("submittedAt", ">=", startISO), this.where("submittedAt", "<=", endISO) ); const snap = await this.getDocs(q); return snap.docs.map(doc => ({ id: doc.id, ...doc.data() })); } async fetchRoutes(userId, startISO, endISO) { const q = this.query( this.collection(this.db, "route_logs"), this.where("userId", "==", userId), this.where("timestamp", ">=", startISO), this.where("timestamp", "<=", endISO) ); const snap = await this.getDocs(q); return snap.docs.map(doc => ({ id: doc.id, ...doc.data() })); } async fetchDashcamClips(userId, startISO, endISO) { const q = this.query( this.collection(this.db, "dashcam_clips"), this.where("userId", "==", userId), this.where("timestamp", ">=", startISO), this.where("timestamp", "<=", endISO) ); const snap = await this.getDocs(q); return snap.docs.map(doc => ({ id: doc.id, ...doc.data() })); } async fetchDispatch(userId, dateString) { const q = this.query( this.collection(this.db, "dispatch_schedule"), this.where("date", "==", dateString) ); const snap = await this.getDocs(q); const jobs = []; snap.forEach(doc => { const data = doc.data(); if (Array.isArray(data.crew)) { const member = data.crew.find(m => m.userId === userId); if (member) { jobs.push({ id: doc.id, clientName: data.clientName, siteAddress: data.siteAddress, role: member.note, asset: member.assetName, shopTime: data.shopTime }); } } else if (typeof data.crew === 'string' && data.crew.includes(userId)) { jobs.push({ id: doc.id, clientName: data.clientName, legacy: true }); } }); return jobs; } calculateSummary(timeLogs, tickets, routes) { let totalHours = 0; let totalLoads = 0; let totalKms = 0; timeLogs.forEach(log => { if (log.endTime) { const start = new Date(log.startTime); const end = new Date(log.endTime); totalHours += (end - start) / 3600000; } else { const start = new Date(log.startTime); const now = new Date(); totalHours += (now - start) / 3600000; } }); tickets.forEach(t => { if (t.unitType === 'Loads') totalLoads += parseFloat(t.quantity) || 0; }); return { hours: totalHours.toFixed(2), loads: totalLoads, jobsCount: new Set(timeLogs.map(l => l.jobId)).size }; } }