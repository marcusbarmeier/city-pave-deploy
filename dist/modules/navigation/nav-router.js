// Â© 2025 City Pave. All Rights Reserved. Unauthorized copying is prohibited.
export class NavRouter { constructor() { this.directionsService = null; this.currentRoute = null; } init() { if (window.google && window.google.maps) { this.directionsService = new google.maps.DirectionsService(); } } async calculateRoute(origin, destination, profile = 'truck', options = {}) { if (!this.directionsService) this.init(); if (!this.directionsService) throw new Error("Google Maps API not loaded"); const request = { origin: origin, destination: destination, travelMode: google.maps.TravelMode.DRIVING, provideRouteAlternatives: true, avoidTolls: options.avoidTolls || false, avoidHighways: options.avoidHighways || false }; return new Promise((resolve, reject) => { this.directionsService.route(request, (result, status) => { if (status === 'OK') { this.currentRoute = result; resolve({ result: result, warning: profile === 'truck' ? "Verify Truck Restrictions Manually" : null }); } else { reject(status); } }); }); } getNextInstruction(stepIndex = 0) { if (!this.currentRoute || !this.currentRoute.routes[0]) return null; const leg = this.currentRoute.routes[0].legs[0]; if (stepIndex < leg.steps.length) { return { instruction: leg.steps[stepIndex].instructions, distance: leg.steps[stepIndex].distance.text, maneuver: leg.steps[stepIndex].maneuver, endLocation: leg.steps[stepIndex].end_location }; } return { instruction: "Arrived at Destination", distance: "0 m" }; } getStepIndexForLocation(currentStep, userLoc) { if (!this.currentRoute || !this.currentRoute.routes[0]) return 0; const leg = this.currentRoute.routes[0].legs[0]; if (currentStep >= leg.steps.length) return leg.steps.length - 1; const stepEnd = leg.steps[currentStep].end_location; const dist = this.getDistanceFromLatLonInMeters( userLoc.lat, userLoc.lng, stepEnd.lat(), stepEnd.lng() ); if (dist < 40) { return Math.min(currentStep + 1, leg.steps.length - 1); } return currentStep; } getDistanceFromLatLonInMeters(lat1, lon1, lat2, lon2) { var R = 6371; var dLat = this.deg2rad(lat2 - lat1); var dLon = this.deg2rad(lon2 - lon1); var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(this.deg2rad(lat1)) * Math.cos(this.deg2rad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2); var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); var d = R * c * 1000; return d; } deg2rad(deg) { return deg * (Math.PI / 180); } }