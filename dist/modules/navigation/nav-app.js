// Â© 2025 City Pave. All Rights Reserved. Unauthorized copying is prohibited.
import { CockpitDashboard } from './cockpit-mode.js'; import { NavRouter } from './nav-router.js'; import { GeofenceManager } from './nav-geofence.js'; import { UnexpectedStopMonitor } from './unexpected-stops.js'; import { ImpactMonitor } from './impact-monitor.js'; import { DashCamManager } from './dash-cam.js'; import { DispatchManager } from './dispatch-logic.js'; export class NavigationApp { constructor(mapDivId, uiDivId) { this.mapContainer = document.getElementById(mapDivId); this.ui = new CockpitDashboard(uiDivId); this.router = new NavRouter(this); this.geofence = new GeofenceManager(this); this.dashCam = new DashCamManager('dashcam-display'); this.impactMonitor = new ImpactMonitor({ onImpact: (data) => this.handleImpactDetected(data), }); this.impactMonitor.onLiveReading = (force) => { this.ui.updateGForce(force); }; this.impactMonitor.start(); this.dispatchManager = new DispatchManager(this); this.camModeIndex = 0; this.camModes = ['off', 'main', 'selfie', 'dual']; this.currentUser = null; this.userLocation = null; this.isNavigating = false; this.currentDestination = null; this.currentAssignment = null; this.routeOptions = { avoidWeighStations: false, truckRoute: true }; this.stopMonitor = new UnexpectedStopMonitor({ distanceThreshold: 20, timeThreshold: 5 * 60 * 1000, debug: true, onStopDetected: (elapsed) => this.handleUnexpectedStop(elapsed), onMotionDetected: () => this.ui.hidePrompt() }); this.currentStepIndex = 0; this.standbyUntil = null; } async init(user) { this.currentUser = user; try { window.currentUser = user; const aiModule = await import('../ai-overlay/ai-overlay.js'); const aiOverlay = aiModule.default; if (aiOverlay) { await aiOverlay.init(); console.log("[NavApp] AI Overlay Loaded Successfully"); } } catch (err) { console.warn("[NavApp] AI Overlay Failed to Load - Continuing without it.", err); this.ui.showAiAlert("AI Assistant Unavailable", "warning"); } this.initMap(); this.addDefaultZones(); this.startLocationWatch(); this.ui.init(user); this.dashCam.startCamera('main'); const urlParams = new URLSearchParams(window.location.search); const mode = urlParams.get('mode'); if (mode === 'dashcam') { console.log("Auto-starting Dash Cam Mode..."); setTimeout(() => { if (this.ui.onDashCamToggle) { this.ui.onDashCamToggle(); this.ui.showAiAlert("Dash Cam Auto-Started", "success"); } }, 1000); } else if (mode === 'hazard') { } this.ui.onMissionChanged = (selection) => { this.handleMissionSelection(selection); }; this.ui.onDashCamToggle = async () => { this.camModeIndex = (this.camModeIndex + 1) % this.camModes.length; const newMode = this.camModes[this.camModeIndex]; console.log("Switching Dash Cam to:", newMode); await this.dashCam.startCamera(newMode); const label = document.getElementById('cam-status'); const recDot = document.getElementById('rec-dot'); const snapBtn = document.getElementById('btn-snapshot'); if (label) { label.innerText = newMode.toUpperCase(); label.className = newMode === 'off' ? 'text-[10px] text-slate-500 uppercase' : 'text-[10px] text-green-400 font-bold uppercase'; } if (recDot) recDot.classList.toggle('hidden', newMode === 'off'); const controls = document.getElementById('cam-controls'); if (controls) { controls.classList.toggle('hidden', newMode === 'off'); console.log("Toggled Controls:", newMode !== 'off'); } else { console.error("Critical: cam-controls element not found in DOM"); } this.ui.showAiAlert(`Dash Cam: ${newMode.toUpperCase()}`, 'info'); }; this.ui.onCamSwitch = async () => { let nextIndex = this.camModeIndex + 1; if (nextIndex >= this.camModes.length) nextIndex = 0; this.camModeIndex = nextIndex; const newMode = this.camModes[this.camModeIndex]; console.log("Switching Camera Source to:", newMode); await this.dashCam.startCamera(newMode); const videoContainer = document.getElementById('dashcam-display'); if (videoContainer) { const videos = videoContainer.querySelectorAll('video'); videos.forEach(v => v.classList.remove('hidden')); } const recDotTop = document.getElementById('rec-dot-top'); if (recDotTop) { if (newMode === 'off') { recDotTop.className = "w-2 h-2 rounded-full bg-slate-600"; } else { recDotTop.className = "w-2 h-2 rounded-full bg-red-500 animate-pulse"; } } this.ui.showAiAlert(`Camera Source: ${newMode.toUpperCase()}`, 'info'); }; this.ui.onSnapshot = () => { const imgData = this.dashCam.takeSnapshot(); if (imgData) { this.ui.showAiAlert("Snapshot Saved", "success"); } }; this.ui.onRecordClip = () => { this.dashCam.triggerIncident(0, 'Manual Request'); this.ui.showAiAlert("Saving Incident Clip...", "warning"); }; this.ui.onMenuAction = () => { this.ui.showPrompt("System Menu", "Select an option:", [ { label: "Route Settings", style: "bg-blue-600", onClick: () => { this.ui.renderRouteOptions(this.routeOptions, (newOpts) => { this.updateRouteOptions(newOpts); this.ui.showAiAlert("Route Options Updated", "info"); }); } }, { label: "Dash Cam Sensitivity", style: "bg-indigo-600", onClick: () => { this.ui.showPrompt("Impact Sensitivity", "Adjust sensor for road conditions:", [ { label: "Highway (High Sensitivity)", onClick: () => { this.impactMonitor.setSensitivity('smooth'); this.ui.showAiAlert("Sensitivity: High", "info"); } }, { label: "Bumpy Road (Low Sensitivity)", onClick: () => { this.impactMonitor.setSensitivity('bumpy'); this.ui.showAiAlert("Sensitivity: Low (Bumpy)", "info"); } } ]); } }, { label: "Job Details", style: "bg-gray-600", onClick: () => { this.ui.renderJobDetailsModal(this.currentAssignment); } }, { label: "Close", style: "bg-gray-800", onClick: () => { } } ]); }; this.ui.onLoadComplete = async (data) => { console.log("Processing Load Data:", data); const entry = { type: 'load_report', timestamp: new Date().toISOString(), ...data, location: this.userLocation || {}, jobId: this.currentAssignment ? this.currentAssignment.id : 'adhoc' }; if (window.firebaseServices) { const { db, addDoc, collection } = window.firebaseServices; if (db) { try { await addDoc(collection(db, "job_tickets"), entry); this.ui.showAiAlert("Ticket Synced to Office", "info"); } catch (e) { console.error("Sync Failed", e); this.ui.showAiAlert("Offline: Ticket Saved Locally", "warning"); } } } }; this.geofence.on('enter', (zone) => this.handleZoneEnter(zone)); this.geofence.on('exit', (data) => this.handleZoneExit(data)); window.addEventListener('system-emergency', (e) => { console.log("[NavApp] System Emergency Detected via Global Event:", e.detail); this.handleIncidentReport({ type: 'Accident', description: 'AI/Red Phone Emergency Trigger', externalId: e.detail.incidentId }); }); this.ui.onLoadComplete = (data) => this.logLoad(data); this.ui.onMissionChanged = (mission) => this.handleMissionSelection(mission); this.ui.onRouteRequested = (routeData) => { console.log("Manual Route Requested:", routeData); this.startRouteTo(routeData.dest); if (this.isManualMode && routeData.start && routeData.start !== 'Current Location') { this.ui.showAiAlert(`Start point set to: ${routeData.start}`, 'info'); } }; this.ui.onExceptionLogged = (data) => this.handleIncidentReport(data); this.listenToDispatch(); } handleIncidentReport(data) { console.log("Incident Reported:", data); if (window.firebaseServices) { const { db, addDoc, collection } = window.firebaseServices; if (db) { addDoc(collection(db, 'daily_logs'), { type: 'incident', timestamp: new Date().toISOString(), ...data, user: this.currentUser ? this.currentUser.uid : 'guest' }); } } switch (data.type) { case 'Accident': case 'Accident / Crash': this.ui.showAiAlert("Emergency Protocol Initiated", "warning"); this.dashCam.triggerIncident(0, `Manual Report: ${data.description || 'Crash'}`); break; case 'Breakdown': this.ui.showAiAlert("Maintenance Ticket Created. Dispatch Notified.", "warning"); break; case 'Supply': this.ui.showAiAlert("Supply Run Logged. Please scan receipts.", "info"); break; case 'Traffic': this.ui.showAiAlert("Traffic Delay Recorded.", "info"); break; default: this.ui.showAiAlert("Status Logged.", "info"); } this.standbyUntil = new Date(Date.now() + 60 * 60000); } bindGlobalEvents() { } async loadDashboardData() { this.ui.show(true); const saved = localStorage.getItem('nav_session'); const session = saved ? JSON.parse(saved) : null; const { db, collection, query, where, getDocs } = window.firebaseServices; let myAssignments = []; let openDispatches = []; try { const q = query(collection(db, "dispatch_schedule")); const snap = await getDocs(q); snap.forEach(doc => { const data = doc.data(); data.id = doc.id; if (data.status === 'Open') { openDispatches.push(data); } else { myAssignments.push(data); } }); if (myAssignments.length === 0 && openDispatches.length === 0) { console.log("No dispatches found. Attempting to generate test data..."); await this.createTestDispatch(); return this.loadDashboardData(); } } catch (e) { console.error("Error loading dashboard data:", e); } const activeProjects = []; this.ui.renderSmartDashboard({ session, myAssignments, openDispatches, activeProjects }, (action, data) => this.handleDashboardAction(action, data)); } async createTestDispatch() { const { db, collection, addDoc } = window.firebaseServices; const testJob = { clientName: "Test: Downtown Plaza", siteAddress: "555 Hennepin Ave, Minneapolis, MN", jobType: "Paving", date: new Date().toISOString().split('T')[0], status: "Dispatched", description: "Repair potholes near entrance.", contactPhone: "555-123-4567", foremanPhone: "555-987-6543", siteTime: "07:00", shopTime: "06:30", notes: "Gate code is 1234. Watch for pedestrians.", equipment: "Paver (Unit 102), Roller", material: "4 tons Asphalt", tools: "Shovels, Rakes", toolboxLocation: "Site Entrance", toolboxTime: "07:00", customHazards: ["Traffic", "Heat"], swpList: ["PPE Required", "Traffic Control"], createdAt: new Date().toISOString() }; try { await addDoc(collection(db, "dispatch_schedule"), testJob); console.log("Test Dispatch Created!"); } catch (e) { console.error("Failed to create test dispatch", e); } } handleDashboardAction(action, data) { const area = document.getElementById('nav-alert-area'); if (area) { area.innerHTML = ''; area.style.pointerEvents = 'none'; } if (action === 'resume') { this.restoreSession(data); } else if (action === 'priority') { this.handleNewAssignment(data); } else if (action === 'ui:report-stop') { this.triggerStopExceptionPrompt(); } else if (action === 'ui:load') { this.ui.renderLoadWizard((data) => this.logLoad(data)); } else if (action === 'claim') { this.handleNewAssignment(data); } else if (action === 'open') { console.log("Claiming Job:", data.clientName); this.logNavigationTime("claim_job", data); this.handleNewAssignment(data); } else if (action === 'manual') { this.openManualSearch(); } } showWelcome() { this.loadDashboardData(); } openManualSearch() { this.ui.renderManualSearchModal((address) => { const customJob = { clientName: "Verbal/Custom: " + address.split(',')[0], siteAddress: address, description: "Manual navigation entry - Verbal Instruction", isAdHoc: true, id: 'custom-' + Date.now() }; this.handleNewAssignment(customJob); }, () => this.showWelcome()); } showJobList() { this.ui.showPrompt("Dispatch List", "Searching for assigned jobs...", [ { label: "Cancel", onClick: () => this.showWelcome() } ]); } saveSession() { if (!this.isNavigating || !this.currentAssignment) return; const session = { assignment: this.currentAssignment, dest: this.currentDestination, startTime: Date.now(), clientName: this.currentAssignment.clientName }; localStorage.setItem('nav_session', JSON.stringify(session)); } clearSession() { localStorage.removeItem('nav_session'); } restoreSession(session) { console.log("Restoring Session...", session.clientName); this.handleNewAssignment(session.assignment); } handleAddStopRequest() { this.ui.showPrompt("Add a Stop", "What do you need?", [ { label: "â›½ Fuel", style: "bg-blue-600", onClick: () => this.addStop("Gas Station") }, { label: "â˜• Coffee / Food", style: "bg-amber-600", onClick: () => this.addStop("Coffee Shop") }, { label: "ðŸ” Search...", style: "bg-gray-600", onClick: () => alert("Search Feature Coming Soon") } ]); } addStop(category) { console.log("Adding Stop:", category); this.ui.showPrompt("Rerouting...", `Finding nearest ${category} along route...`, [{ label: "Close" }]); } async updateRouteOptions(newOpts) { console.log("Updating Route Options:", newOpts); this.routeOptions = newOpts; if (this.isNavigating && this.currentDestination && this.userLocation) { try { const { result, warning } = await this.router.calculateRoute(this.userLocation, this.currentDestination, 'truck', this.routeOptions); if (warning) this.ui.showAiAlert(warning, 'warning'); const legs = result.routes[0].legs[0]; const steps = legs.steps; this.ui.renderDirectionsList(steps, () => { this.directionsRenderer.setDirections(result); const leg = legs; this.currentDestination = { lat: leg.end_location.lat(), lng: leg.end_location.lng() }; this.isNavigating = true; this.currentStepIndex = 0; this.updateInstruction(); }); this.directionsRenderer.setDirections(result); } catch (e) { console.error("Route Error:", e); this.isNavigating = false; this.ui.showAiAlert("Route Failed: " + e, "error"); } } } listenToDispatch() { if (!window.firebaseServices) return; const { db, collection, query, where, onSnapshot } = window.firebaseServices; if (!db) return; const today = new Date().toISOString().split('T')[0]; const q = query( collection(db, "dispatch_schedule"), where("date", "==", today) ); onSnapshot(q, (snapshot) => { snapshot.forEach(doc => { const data = doc.data(); const isMyJob = data.crew && data.crew.some(c => c.userId === this.currentUser.uid); if (isMyJob) { this.handleNewAssignment(data); } }); }); } async handleNewAssignment(data) { console.log("New Assignment Received:", data.clientName); this.currentAssignment = data; this.ui.updateJobTitle(data.clientName); this.ui.showPrompt("New Dispatch", `Assignment: ${data.clientName}`, [ { label: "Accept & Route to Site", style: "bg-blue-600", onClick: () => this.startRouteTo(data.siteAddress, 'job', data.clientName) } ]); if (data.siteAddress) this.addGeofenceFromAddress(data.siteAddress, 'job', data.clientName); if (data.dumpAddress) this.addGeofenceFromAddress(data.dumpAddress, 'dump', "Dump Site"); } async addGeofenceFromAddress(address, type, name) { if (!window.google) return; const geocoder = new google.maps.Geocoder(); try { const result = await geocoder.geocode({ address: address }); if (result.results && result.results[0]) { const loc = result.results[0].geometry.location; const radius = 200; const path = []; for (let i = 0; i < 360; i += 10) { path.push(google.maps.geometry.spherical.computeOffset(loc, radius, i)); } this.geofence.addZone({ id: `${type}-${Date.now()}`, name: name, type: type, paths: path }); } } catch (e) { console.error("Geocoding failed for fence", e); } } async startRouteTo(target, type, name) { let dest = null; if (typeof target === 'object' && target.lat && target.lng) { dest = target; } else if (window.google) { const geocoder = new google.maps.Geocoder(); try { const result = await geocoder.geocode({ address: target }); if (result.results && result.results[0]) { const destLoc = result.results[0].geometry.location; dest = { lat: destLoc.lat(), lng: destLoc.lng() }; } } catch (e) { console.error("Geocoding failed", e); } } if (!dest) { console.error("Could not resolve destination:", target); return; } this.currentDestination = dest; this.isNavigating = true; this.ui.show(true); this.ui.updateZone("En Route", "transit"); this.currentStepIndex = 0; this.saveSession(); this.logNavigationTime('start_nav', { clientName: name, id: this.currentAssignment ? this.currentAssignment.id : 'manual' }); const alertArea = document.getElementById('nav-alert-area'); if (alertArea) { alertArea.innerHTML = ''; alertArea.style.pointerEvents = 'none'; } if (!this.userLocation) { console.log("Waiting for GPS to calculate route..."); this.pendingDestination = { target, type, name }; this.ui.showPrompt("Waiting for GPS", "Acquiring your location to verify route...", [ { label: "Cancel", onClick: () => { this.isNavigating = false; this.pendingDestination = null; this.ui.updateZone("Not Navigating", "unknown"); this.showWelcome(); } } ]); return; } try { const { result, warning } = await this.router.calculateRoute(this.userLocation, dest, 'truck', this.routeOptions); this.directionsRenderer.setDirections(result); const step1 = this.router.getNextInstruction(0); if (step1) { this.ui.updateInstruction(step1.instruction, step1.distance); const leg = result.routes[0].legs[0]; const etaEl = document.getElementById('nav-eta'); if (etaEl) { etaEl.textContent = "ETA: " + leg.duration.text; etaEl.classList.remove('hidden'); } } } catch (e) { console.error("Route failed", e); this.ui.showPrompt("Route Error", "Could not calculate directions to this location.", [{ label: "OK" }]); } } initMap() { if (!window.google) return; this.map = new google.maps.Map(this.mapContainer, { center: { lat: 44.9778, lng: -93.2650 }, zoom: 14, disableDefaultUI: true, styles: [ { elementType: "geometry", stylers: [{ color: "#242f3e" }] }, { elementType: "labels.text.stroke", stylers: [{ color: "#242f3e" }] }, { elementType: "labels.text.fill", stylers: [{ color: "#746855" }] }, { featureType: "road", elementType: "geometry", stylers: [{ color: "#38414e" }] }, { featureType: "road", elementType: "geometry.stroke", stylers: [{ color: "#212a37" }] }, { featureType: "road", elementType: "labels.text.fill", stylers: [{ color: "#9ca5b3" }] }, { featureType: "water", elementType: "geometry", stylers: [{ color: "#17263c" }] } ] }); this.directionsRenderer = new google.maps.DirectionsRenderer({ suppressMarkers: true, polylineOptions: { strokeColor: "#6366f1", strokeWeight: 6 } }); this.directionsRenderer.setMap(this.map); } async handleImpactDetected(data) { console.warn("IMPACT HANDLER:", data); this.ui.showAiAlert(`IMPACT DETECTED (${data.gForce.toFixed(1)}G) - SAVING EVIDENCE`, "error"); const incident = await this.dashCam.triggerIncident("impact"); if (incident) { setTimeout(async () => { const clip = await this.dashCam.saveIncidentClip(); if (clip) { this.ui.showAiAlert(`Evidence Saved: ${clip.sizeMb}MB`, "success"); } }, 5000); } } addDefaultZones() { const shopPath = [ { lat: 44.9800, lng: -93.2700 }, { lat: 44.9800, lng: -93.2600 }, { lat: 44.9750, lng: -93.2600 }, { lat: 44.9750, lng: -93.2700 } ]; this.geofence.addZone({ id: 'shop-main', name: 'Central Yard', type: 'shop', paths: shopPath }); const plantPath = [ { lat: 44.9700, lng: -93.2750 }, { lat: 44.9700, lng: -93.2650 }, { lat: 44.9650, lng: -93.2650 }, { lat: 44.9650, lng: -93.2750 } ]; this.geofence.addZone({ id: 'plant-mock-1', name: 'City Pave - Asphalt Plant', type: 'plant', paths: plantPath }); console.log("Default Zones Added (Shop + Plant)"); } startLocationWatch() { if (!navigator.geolocation) { console.error("GPS Not Supported"); this.handleGpsTimeout(); return; } const gpsTimeout = setTimeout(() => { if (!this.userLocation) { console.warn("GPS Timed out - Defaulting to Shop Location"); this.ui.updateConnectionStatus("offline"); this.handleGpsTimeout(); } }, 8000); this.ui.updateConnectionStatus("connecting"); this.watchId = navigator.geolocation.watchPosition((pos) => { clearTimeout(gpsTimeout); this.ui.updateConnectionStatus("online"); const crd = pos.coords; this.updateLocationState({ lat: crd.latitude, lng: crd.longitude, heading: crd.heading, speed: crd.speed }); }, (err) => { console.warn("GPS Error:", err); }, { enableHighAccuracy: true, maximumAge: 0, timeout: 8000 }); } handleGpsTimeout() { this.ui.showPrompt("GPS Signal Not Detected", "Would you like to enter Manual Mode? You will need to manually log your locations and times.", [ { label: "Retry GPS", onClick: () => { this.ui.showAiAlert("Retrying GPS Signal...", "info"); } }, { label: "Enter Manual Mode", style: "bg-amber-600 hover:bg-amber-700 text-white font-bold py-4", onClick: () => this.activateManualMode() } ]); } activateManualMode() { this.isManualMode = true; this.ui.updateConnectionStatus("offline"); this.ui.showAiAlert("Manual Mode Activated", "warning"); this.ui.renderManualSearchModal((address) => { this.manualLocationName = address; this.ui.updateJobTitle(address ? `At: ${address}` : "Manual Location"); this.ui.showPrompt("Manual Entry", "What are you doing right now?", [ { label: "Starting Day / departing Shop", onClick: () => this.logManualAction("Departed Shop", address) }, { label: "Arriving at Job", onClick: () => this.logManualAction("Arrived at Job", address) }, { label: "Just viewing map", onClick: () => { } } ]); }); } logManualAction(actionName, locationName) { const time = new Date().toLocaleTimeString(); this.ui.showAiAlert(`Logged: ${actionName} at ${time}`, "info"); const entry = { type: 'manual_log', action: actionName, location: locationName || "Manual Entry", timestamp: new Date().toISOString(), userManual: true }; if (window.firebaseServices) { const { db, addDoc, collection } = window.firebaseServices; addDoc(collection(db, "driver_logs"), entry).catch(console.error); } } updateLocationState(data) { this.userLocation = { lat: data.lat, lng: data.lng }; if (this.pendingDestination) { console.log("GPS Acquired. Resuming route..."); this.startRouteTo(this.pendingDestination.target, this.pendingDestination.type, this.pendingDestination.name); this.pendingDestination = null; } if (!this.userMarker && this.map) { this.userMarker = new google.maps.Marker({ map: this.map, position: this.userLocation, icon: { path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW, scale: 6, fillColor: "#4F46E5", fillOpacity: 1, strokeWeight: 2, strokeColor: "white", rotation: data.heading || 0 }, title: "Your Truck" }); this.map.panTo(this.userLocation); } else if (this.userMarker) { this.userMarker.setPosition(this.userLocation); if (data.heading !== null) { const icon = this.userMarker.getIcon(); if (icon) { icon.rotation = data.heading; this.userMarker.setIcon(icon); } } } if ((this.isNavigating || window.SIM_MODE) && this.map) { this.map.panTo(this.userLocation); if (this.isNavigating) { const newStep = this.router.getStepIndexForLocation(this.currentStepIndex, this.userLocation); if (newStep !== this.currentStepIndex) { this.currentStepIndex = newStep; } const instruction = this.router.getNextInstruction(this.currentStepIndex); if (instruction) { this.ui.updateInstruction(instruction.instruction, instruction.distance); } } } this.geofence.checkLocation(this.userLocation); const speedMph = (data.speed || 0) * 2.23694; this.ui.updateSpeed(speedMph); this.monitorExceptions(speedMph, this.userLocation); this.stopMonitor.updateLocation(this.userLocation); this.recordBreadcrumb(this.userLocation, speedMph, data.heading); } async updateDispatcher(location) { if (!this.currentUser) return; this.stopMonitor.updateLocation(location); if (window.firebaseServices && window.firebaseServices.db) { } } async recordBreadcrumb(location, speed, heading) { if (!this.currentUser) return; const now = Date.now(); const interval = window.SIM_MODE ? 3000 : 60000; if (this.lastBreadcrumbTime && (now - this.lastBreadcrumbTime < interval)) { return; } this.lastBreadcrumbTime = now; if (!window.firebaseServices) return; const { db, collection, addDoc } = window.firebaseServices; if (!db) return; try { await addDoc(collection(db, "breadcrumbs"), { userId: this.currentUser.uid, userName: this.currentUser.displayName || "Driver", timestamp: new Date().toISOString(), location: location, speed: speed, heading: heading || 0, isSimulation: window.SIM_MODE || false }); console.log("Breadcrumb logged."); } catch (e) { console.error("Breadcrumb Log Failed", e); } } monitorExceptions(speed, location) { if (this.standbyUntil) { if (new Date() < this.standbyUntil) { return; } else { this.standbyUntil = null; } } if (speed < 3) { if (!this.stopStartTime) { this.stopStartTime = Date.now(); } else { const elapsed = (Date.now() - this.stopStartTime) / 1000 / 60; const thresholdMinutes = window.SIM_MODE ? 2 : 15; if (elapsed > thresholdMinutes && !this.geofence.getCurrentZone() && !this.isPromptActive) { this.triggerStopExceptionPrompt(); } } } else { this.stopStartTime = null; } } triggerStopExceptionPrompt() { if (this.isPromptActive) return; this.isPromptActive = true; this.ui.renderIncidentModal((data) => { console.log("Stop Reason Logged:", data); this.handleIncidentReport(data); this.isPromptActive = false; }); this.ui.showAiAlert("Unexpected Stop Detected. Please report reason.", "warning"); } async startStandby(reason, durationMinutes) { console.log(`Starting Standby: ${reason} for ${durationMinutes}m`); this.isPromptActive = false; const now = new Date(); this.standbyUntil = new Date(now.getTime() + durationMinutes * 60000); if (this.currentUser && window.firebaseServices) { const { db, addDoc, collection } = window.firebaseServices; try { await addDoc(collection(db, "daily_logs"), { userId: this.currentUser.uid, userName: this.currentUser.displayName || "Driver", type: "standby_start", reason: reason, durationEstimated: durationMinutes, jobId: this.currentAssignment ? this.currentAssignment.id : 'adhoc', location: this.userLocation, timestamp: now.toISOString() }); alert(`Standby Mode Active until ${this.standbyUntil.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`); } catch (e) { console.error("Failed to log standby", e); } } } checkMovement() { if (!this.userLocation || !this.lastLocation) return; if (this.standbyUntil && new Date() < this.standbyUntil) { console.log("In Standby Mode - suppressing alerts"); return; } else if (this.standbyUntil) { this.standbyUntil = null; } } async logException(reason) { console.log("Logging exception:", reason); this.isPromptActive = false; this.stopStartTime = null; if (reason === 'Standby') { this.ui.showStandbyModal((r, d) => this.startStandby(r, d)); return; } if (!window.firebaseServices) { this.handleExceptionRedirect(reason); return; } const { db, addDoc, collection } = window.firebaseServices; if (!db || !this.currentUser) { this.handleExceptionRedirect(reason); return; } try { await addDoc(collection(db, "daily_logs"), { userId: this.currentUser.uid, userName: this.currentUser.displayName || "Driver", type: "exception", reason: reason, location: this.userLocation, timestamp: new Date().toISOString() }); this.handleExceptionRedirect(reason); } catch (e) { console.error("Failed to log exception", e); this.handleExceptionRedirect(reason); } } handleExceptionRedirect(reason) { if (reason === 'Breakdown') { window.location.href = '../employee/index.html?mode=repair'; } else if (reason === 'Parts') { window.location.href = '../inventory_manager/index.html'; } else if (reason === 'Fuel') { window.location.href = '../expense_manager/index.html?mode=fuel'; } else if (reason === 'Supply') { if (confirm("Go to Inventory Manager for PARTS? (Cancel for EXPENSES/Supplies)")) { window.location.href = '../inventory_manager/index.html'; } else { window.location.href = '../expense_manager/index.html'; } } } async logLoad(loadData) { console.log("Logging Load:", loadData); if (!window.firebaseServices || !this.currentUser) { alert("Load Logged (Demo Mode)\nMaterial: " + loadData.material); return; } const { db, addDoc, collection } = window.firebaseServices; try { await addDoc(collection(db, "daily_logs"), { userId: this.currentUser.uid, userName: this.currentUser.displayName || "Driver", type: loadData.hasTicket ? "ticket" : "load", jobId: this.currentAssignment ? this.currentAssignment.id : 'adhoc', location: this.userLocation, timestamp: new Date().toISOString(), material: loadData.material, ticketText: loadData.ticketText, hasTicket: loadData.hasTicket, safety: { isClean: loadData.isClean, notOverloaded: loadData.notOverloaded, concerns: loadData.safetyConcerns }, damage: loadData.hasDamage ? { description: loadData.damageDescription, operator: loadData.operatorName, hasSignature: loadData.operatorSignature } : null }); alert("Load Logged Successfully! \nSafety Checks Recorded."); } catch (e) { console.error("Failed to log load", e); alert("Error logging load. Please try again."); } } async logNavigationTime(action, data) { const record = { userId: this.currentUser.uid, timestamp: new Date().toISOString(), action: action, jobId: data.id || 'custom', jobName: data.clientName || 'Ad-Hoc', location: this.userLocation || { lat: 0, lng: 0 } }; console.log("LOGGING TIME:", record); if (!window.firebaseServices) return; const { db, addDoc, collection } = window.firebaseServices; if (!db) return; try { await addDoc(collection(db, "employee_time_logs"), record); } catch (e) { console.error("Time Log Failed", e); } } handleZoneEnter(zone) { this.ui.updateZone(zone.name, zone.type); this.logNavigationTime('arrival', { zoneId: zone.id, zoneName: zone.name, type: zone.type }); if (zone.type === 'job') { this.ui.showPrompt( "You have arrived", `Perform Last Minute Hazard Assessment at ${zone.name}?`, [ { label: "Start Assessment", style: "bg-blue-600 hover:bg-blue-700", onClick: () => { console.log("Opening Hazard Assessment..."); window.location.href = '../safety/hazard-assessment.html?jobId=' + (this.currentAssignment ? this.currentAssignment.id : 'adhoc'); } }, { label: "Already Done", style: "bg-green-600 hover:bg-green-700", onClick: () => this.logException("Hazard Assessment Confirmed") } ] ); } else if (zone.type === 'plant') { this.triggerVoiceLoadProtocol(zone.name); } } handleZoneExit({ zone, duration }) { this.ui.updateZone("In Transit", "transit"); if (zone && zone.type === 'dump') { const minutes = duration / 1000 / 60; const threshold = window.SIM_MODE ? 0.1 : 2; if (minutes > threshold) { this.ui.showPrompt( "Load Count", "Did you dump a load?", [ { label: "Yes, Count Load", style: "bg-blue-600", onClick: () => console.log("Load +1") }, { label: "No", style: "bg-gray-500", onClick: () => { } } ] ); } } } handleUnexpectedStop(elapsed) { console.warn("Unexpected Stop Detected!", elapsed); this.ui.showPrompt("Unexpected Stop Detected", "We noticed you haven't moved in a while. Everything okay?", [ { label: "Traffic", style: "bg-yellow-600", onClick: () => this.logStopReason("Traffic") }, { label: "Breakdown / Issue", style: "bg-red-600", onClick: () => this.triggerBreakdownFlow() }, { label: "Rest Stop", style: "bg-blue-600", onClick: () => this.logStopReason("Rest") }, { label: "Just waiting", style: "bg-gray-600", onClick: () => this.stopMonitor.reset() } ]); } logStopReason(reason) { this.ui.showAiAlert(`Status Logged: ${reason}`, "info"); this.stopMonitor.reset(); } handleMissionSelection(selection) { console.log("Processing Mission Selection:", selection); if (selection.type === 'dispatch') { const job = selection.data; this.currentAssignment = job; this.ui.updateJobTitle(job.client, job); this.ui.showPrompt("Dispatch Accepted", `Navigate to ${job.address}?`, [ { label: "Start Navigation", onClick: () => this.startNavigation(job.location) }, { label: "View Details", style: "bg-gray-600", onClick: () => this.ui.renderJobDetailsModal(job) } ]); } else if (selection.type === 'mission') { const mission = selection.data; this.currentAssignment = { id: mission.id, client: mission.label }; this.ui.updateJobTitle(mission.label, mission); if (mission.id === 'mission-shop') { this.startNavigation({ lat: 34.000, lng: -118.000 }); } } } startNavigation(dest) { this.isNavigating = true; this.currentDestination = dest; this.router.calculateRoute(this.userLocation, dest); this.geofence.addZone({ id: 'job-dest', name: this.currentAssignment.client || 'Destination', lat: dest.lat, lng: dest.lng, radius: 100, type: 'job' }); this.ui.updateZone("Navigating...", "transit"); } triggerBreakdownFlow() { this.ui.showAiAlert("Notifying Dispatch of Breakdown", "warning"); this.stopMonitor.reset(); } triggerVoiceLoadProtocol(plantName) { const greeting = `Arrived at ${plantName}. What are you picking up?`; this.speak(greeting); this.ui.showPrompt("AI Co-Pilot", "Listening... (Speak now)", [ { label: "ðŸŽ¤ simulate: '10 tons of Gravel'", style: "bg-indigo-600 hover:bg-indigo-700 animate-pulse", onClick: () => this.handleVoiceCommand("I'm picking up 10 tons of Gravel") }, { label: "ðŸŽ¤ simulate: '5 tons Asphalt'", style: "bg-indigo-600 hover:bg-indigo-700", onClick: () => this.handleVoiceCommand("Got 5 tons of Asphalt") }, { label: "Cancel / Manual", style: "bg-gray-600", onClick: () => this.ui.renderLoadWizard((data) => this.logLoad(data)) } ]); } handleVoiceCommand(transcript) { this.ui.showAiAlert(`Heard: "${transcript}"`, "info"); const quantityMatch = transcript.match(/(\d+)\s*(tons?|loads?)/i); const materialMatch = transcript.match(/(gravel|asphalt|sand|dirt|base|concrete)/i); const quantity = quantityMatch ? quantityMatch[1] : null; const material = materialMatch ? materialMatch[0] : "Unknown Material"; if (quantity && material) { this.speak(`Copy that. ${quantity} tons of ${material}. Loading Ticket.`); this.ui.renderLoadWizard((data) => this.logLoad(data), { autoFill: { quantity: quantity, material: material, hasTicket: true } }); } else { this.speak("I didn't catch that. Please enter manually."); this.ui.renderLoadWizard((data) => this.logLoad(data)); } } speak(text) { if ('speechSynthesis' in window) { const utterance = new SpeechSynthesisUtterance(text); window.speechSynthesis.speak(utterance); } else { console.log("TTS:", text); } } }