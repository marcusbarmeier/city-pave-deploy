// Â© 2025 City Pave. All Rights Reserved. Unauthorized copying is prohibited.
import { getEstimateData, saveEstimate, saveQuickAdd, saveSiteVisit, getOptionData, fetchPricingLibrary } from './estimator-data.js'; import { generatePrintableEstimateHTML } from './outputGenerator.js'; import { handleAutoCalculateSnowPrice, handleRouteChange, applyAllSnowLocationsToOption } from '../snow_calc/snow-app.js'; import { updateSnowContractSummary } from '../snow_calc/snow-ui.js'; import * as ui from './estimator-ui.js'; import { setupEventListeners } from './estimator-events.js'; import { debounce, formatCurrency } from './estimator-utils.js'; import { State } from './estimator-state.js'; const CATEGORIES = ["New Leads", "Ready for Review", "Planned Route (Un-confirmed)", "Site Visits", "Work Starting", "Active Customers", "Inactive Customers", "Follow-up", "Trucking"]; let signaturePad = null; let witnessSignaturePad = null; let autosaveInterval = null; let addressAutocomplete = null; let baUploadContext = null; let deepLinkTarget = null; let currentUserId = null; export async function initializeEstimatorApp() { const brandSelector = document.getElementById('brand-selector'); if (brandSelector) { const currentMode = localStorage.getItem('app_brand_mode') || 'citypave'; brandSelector.value = currentMode; brandSelector.addEventListener('change', (e) => { localStorage.setItem('app_brand_mode', e.target.value); location.reload(); }); } const { auth, onAuthStateChanged, signInAnonymously, db, doc, getDoc } = window.firebaseServices; onAuthStateChanged(auth, async (user) => { if (user) { currentUserId = user.uid; try { const libraryData = await fetchPricingLibrary(); if (libraryData) { window.pricingData = libraryData; console.log("Pricing Library Loaded:", window.pricingData.options.length, "items"); if (window.pricingData.taxRate) window.GLOBAL_TAX_RATE = window.pricingData.taxRate; const pricingContainer = document.getElementById('pricing-options-container'); if (pricingContainer && pricingContainer.children.length === 0) { } } else { console.error("Failed to load pricing library."); ui.showErrorBanner("Critical: Could not load pricing data."); } } catch (err) { console.error("Error during pricing init:", err); } try { const userSnap = await getDoc(doc(db, "users", user.uid)); if (userSnap.exists()) { const userData = userSnap.data(); window.currentUser = userData; if (userData.tenantId) { const tenantSnap = await getDoc(doc(db, "tenants", userData.tenantId)); if (tenantSnap.exists()) { window.currentUser.tenantModules = tenantSnap.data().modules || {}; console.log("Loaded Tenant Modules:", window.currentUser.tenantModules); } } } } catch (e) { console.error("Error loading user/tenant profile:", e); } listenForEstimates(); } else { console.log("No user found. Attempting anonymous sign-in..."); await signInAnonymously(auth).catch(error => { console.error("Anonymous sign-in failed:", error); if (error.code === 'auth/admin-restricted-operation') { ui.showErrorBanner("Guest access disabled."); const magicBtn = document.createElement('button'); magicBtn.innerText = "Tap to Login (Test User)"; magicBtn.style.position = 'fixed'; magicBtn.style.bottom = '20px'; magicBtn.style.left = '50%'; magicBtn.style.transform = 'translateX(-50%)'; magicBtn.style.zIndex = '9999'; magicBtn.style.padding = '15px 30px'; magicBtn.style.backgroundColor = '#2563EB'; magicBtn.style.color = 'white'; magicBtn.style.fontWeight = 'bold'; magicBtn.style.borderRadius = '9999px'; magicBtn.style.boxShadow = '0 4px 6px rgba(0,0,0,0.1)'; magicBtn.style.border = 'none'; magicBtn.onclick = async () => { magicBtn.innerText = "Logging in..."; try { const { signInWithEmailAndPassword } = await import("https: await signInWithEmailAndPassword(auth, "test@citypave.ca", "Password123!"); magicBtn.remove(); window.location.reload(); } catch (e) { magicBtn.innerText = "Login Failed"; alert("Login Error: " + e.message); console.error(e); } }; document.body.appendChild(magicBtn); const signinBtn = document.querySelector('a[href*="signin"]'); if (signinBtn) signinBtn.click(); } else { ui.showErrorBanner("Authentication failed. Please reload."); } }); } }); const loadMoreBtn = document.getElementById('load-more-btn'); if (loadMoreBtn) { loadMoreBtn.addEventListener('click', () => { currentLimit += 50; listenForEstimates(); }); } initializeQuillEditors(); initializeAddressAutocomplete(); initializeEditorSignaturePads(); ui.populateStatusDropdowns(); setupEventListeners({ ui, saveEstimate, allEstimates, undo, redo, applyDashboardFilter, handleCreateNewEstimate, handleFilterClick, handleDashboardCardClick, handleDashboardCardChange, handleStarRatingClick, handleSelectAll, saveQuickAdd, handleNewSketchFromEditor, handleSketchForExisting, handleDeleteConfirmation, saveSiteVisit, saveTags, batchUpdateCategory, handleWorkPhotoUpload, handleBeforeAfterUpload, handleSignedCopyUpload, handleRouteChange, saveContentToEstimate, saveContentAsDefault, handleEditorClicks, resizeAllPads, saveState, getEstimateDataForSave, getAppendixDefaultContent, signaturePad, witnessSignaturePad, debounce, onShowEditor, onHideEditor, initializeDragAndDrop }); initializeTheme(); ui.setupEditorTabs(); const urlParams = new URLSearchParams(window.location.search); const estimateIdFromUrl = urlParams.get('estimateId'); const viewFromUrl = urlParams.get('view'); const sectionFromUrl = urlParams.get('section'); if (estimateIdFromUrl && viewFromUrl === 'editor') { deepLinkTarget = { id: estimateIdFromUrl, section: sectionFromUrl }; } else { ui.showView('dashboard-view', onShowEditor, onHideEditor); } const dashboardHeader = document.querySelector('#dashboard-view header'); if (dashboardHeader && window.appConfig) { const lightLogo = dashboardHeader.querySelector('.logo-light'); const darkLogo = dashboardHeader.querySelector('.logo-dark'); if (lightLogo) lightLogo.src = window.appConfig.logo_light; if (darkLogo) darkLogo.src = window.appConfig.logo_dark; } } function initializeTheme() { const toggle = document.getElementById('dark-mode-toggle'); if (localStorage.getItem('theme') === 'dark') { document.body.classList.add('dark-mode'); if (toggle) toggle.checked = true; } if (toggle) toggle.addEventListener('change', (e) => { document.body.classList.toggle('dark-mode', e.target.checked); localStorage.setItem('theme', e.target.checked ? 'dark' : 'light'); }); } function initializeEditorSignaturePads() { const mainCanvas = document.getElementById('signature-pad'); const witnessCanvas = document.getElementById('witness-signature-pad-editor'); if (mainCanvas) signaturePad = new SignaturePad(mainCanvas, { backgroundColor: 'rgb(249, 250, 251)' }); if (witnessCanvas) witnessSignaturePad = new SignaturePad(witnessCanvas, { backgroundColor: 'rgb(249, 250, 251)' }); const zoomBtn = document.getElementById('zoom-signature-btn'); const zoomModal = document.getElementById('signature-zoom-modal'); const zoomCanvas = document.getElementById('zoom-signature-pad'); const closeZoomBtn = document.getElementById('close-zoom-signature-btn'); const saveZoomBtn = document.getElementById('save-zoom-signature-btn'); const clearZoomBtn = document.getElementById('clear-zoom-signature-btn'); let zoomPad = null; if (zoomCanvas) { zoomPad = new SignaturePad(zoomCanvas, { backgroundColor: 'rgb(255, 255, 255)', minWidth: 2, maxWidth: 4 }); const resizeObserver = new ResizeObserver(() => { if (zoomCanvas.width !== zoomCanvas.offsetWidth || zoomCanvas.height !== zoomCanvas.offsetHeight) { const ratio = Math.max(window.devicePixelRatio || 1, 1); zoomCanvas.width = zoomCanvas.offsetWidth * ratio; zoomCanvas.height = zoomCanvas.offsetHeight * ratio; zoomCanvas.getContext("2d").scale(ratio, ratio); if (zoomPad) zoomPad.clear(); } }); resizeObserver.observe(zoomCanvas.parentElement); } if (zoomBtn && zoomModal) { zoomBtn.addEventListener('click', () => { zoomModal.classList.remove('hidden'); setTimeout(() => { const ratio = Math.max(window.devicePixelRatio || 1, 1); zoomCanvas.width = zoomCanvas.offsetWidth * ratio; zoomCanvas.height = zoomCanvas.offsetHeight * ratio; zoomCanvas.getContext("2d").scale(ratio, ratio); zoomPad.clear(); if (!signaturePad.isEmpty()) { zoomPad.fromData(signaturePad.toData()); } }, 100); }); const closeZoom = () => zoomModal.classList.add('hidden'); closeZoomBtn.addEventListener('click', closeZoom); clearZoomBtn.addEventListener('click', () => zoomPad.clear()); saveZoomBtn.addEventListener('click', () => { if (zoomPad.isEmpty()) { signaturePad.clear(); } else { signaturePad.fromData(zoomPad.toData()); } closeZoom(); }); } } function initializeQuillEditors() { const editorsToInit = { 'manual-scope-editor': [['bold', 'italic', 'underline'], [{ 'list': 'ordered' }, { 'list': 'bullet' }]], 'auto-scope-editor': [['bold', 'italic', 'underline'], [{ 'list': 'ordered' }, { 'list': 'bullet' }]], 'contact-description-editor': [['bold', 'underline'], [{ 'list': 'bullet' }]], 'appendix-editor': [['bold', 'italic', 'underline'], [{ 'header': [1, 2, false] }], [{ 'list': 'ordered' }, { 'list': 'bullet' }]], 'terms-editor': [['bold', 'italic', 'underline'], [{ 'header': [1, 2, false] }], [{ 'list': 'ordered' }, { 'list': 'bullet' }]] }; for (const id in editorsToInit) { if (document.getElementById(id)) { const quill = new Quill(`#${id}`, { modules: { toolbar: editorsToInit[id] }, theme: 'snow' }); ui.setQuillInstance(id.replace('-editor', ''), quill); quill.on('text-change', debounce(saveState, 500)); } } } function initializeAddressAutocomplete() { const checkApi = setInterval(() => { if (window.google?.maps?.places) { clearInterval(checkApi); const addressInput = document.getElementById('customer-address'); if (addressInput && !addressAutocomplete) { addressAutocomplete = new google.maps.places.Autocomplete(addressInput, { types: ['address'], componentRestrictions: { country: 'ca' } }); } } }, 100); } function getGPSLocation(file) { return new Promise((resolve) => { if (!file || !file.type.startsWith('image/')) { resolve(null); return; } EXIF.getData(file, function () { const lat = EXIF.getTag(this, "GPSLatitude"); const lon = EXIF.getTag(this, "GPSLongitude"); const latRef = EXIF.getTag(this, "GPSLatitudeRef"); const lonRef = EXIF.getTag(this, "GPSLongitudeRef"); if (lat && lon && latRef && lonRef) { const toDecimal = (number) => number.length === 3 ? number[0].valueOf() + (number[1].valueOf() / 60) + (number[2].valueOf() / 3600) : 0; let latitude = toDecimal(lat); let longitude = toDecimal(lon); if (latRef === "S") latitude = -latitude; if (lonRef === "W") longitude = -longitude; resolve({ lat: latitude, lng: longitude }); } else { resolve(null); } }); }); } async function handleSignedCopyUpload(e) { const file = e.target.files[0]; if (!file) return; const estimateId = document.getElementById('editing-estimate-id').value; if (!estimateId) { ui.showErrorBanner("Please save the estimate before uploading a signed document."); e.target.value = ''; return; } const { storage, ref, uploadBytes, getDownloadURL, db, doc, updateDoc } = window.firebaseServices; ui.showSuccessBanner("Uploading document...", true); try { const fileRef = ref(storage, `estimates/${estimateId}/signed_copies/signed_copy_${Date.now()}_${file.name}`); const snapshot = await uploadBytes(fileRef, file); const url = await getDownloadURL(snapshot.ref); await updateDoc(doc(db, 'estimates', estimateId), { 'acceptance.signedCopyURL': url }); const estimate = allEstimates.find(est => est.id === estimateId); if (estimate) { if (!estimate.acceptance) estimate.acceptance = {}; estimate.acceptance.signedCopyURL = url; } const signedCopyContainer = document.getElementById('signed-copy-link-container'); if (signedCopyContainer) { signedCopyContainer.innerHTML = ` <a href="${url}" target="_blank" class="text-green-600 font-semibold hover:underline">View Uploaded Document</a> <button type="button" class="remove-signed-copy-btn text-xs text-red-500 hover:underline ml-2 no-print">(Remove)</button>`; signedCopyContainer.querySelector('.remove-signed-copy-btn').onclick = () => handleSignedCopyDelete(); } saveState(); ui.showSuccessBanner("Signed document uploaded successfully."); } catch (error) { console.error("Error uploading signed copy:", error); ui.showErrorBanner(`Upload failed: ${error.message}`); } finally { e.target.value = ''; } } async function handleWorkPhotoUpload(e) { const file = e.target.files[0]; if (!file) return; const estimateId = document.getElementById('editing-estimate-id').value; if (!estimateId) { ui.showErrorBanner("Please save estimate before uploading photos."); return; } const { storage, ref, uploadBytes, getDownloadURL, db, doc, updateDoc, getDoc } = window.firebaseServices; ui.showSuccessBanner("Uploading photo...", true); try { const fileRef = ref(storage, `estimates/${estimateId}/work-photos/${Date.now()}_${file.name}`); const snapshot = await uploadBytes(fileRef, file); const url = await getDownloadURL(snapshot.ref); const estimateRef = doc(db, 'estimates', estimateId); const estimateSnap = await getDoc(estimateRef); const currentData = estimateSnap.exists() ? estimateSnap.data() : {}; const currentPhotos = currentData.workPhotos || []; await updateDoc(estimateRef, { workPhotos: [...currentPhotos, { url, description: '' }] }); const localEstimate = allEstimates.find(est => est.id === estimateId); if (localEstimate) { localEstimate.workPhotos = [...(localEstimate.workPhotos || []), { url, description: '' }]; if (typeof ui.renderWorkPhotos === 'function' && typeof handlePhotoDelete === 'function') { ui.renderWorkPhotos(localEstimate.workPhotos, handlePhotoDelete); } else { console.warn("renderWorkPhotos or handlePhotoDelete not available to update UI immediately."); } } ui.showSuccessBanner("Photo uploaded successfully."); } catch (error) { console.error("Error uploading work photo:", error); ui.showErrorBanner(`Upload failed: ${error.message}`); } finally { e.target.value = ''; } } function handleCreateNewEstimate() { ui.resetEditorForm(getAppendixDefaultContent, saveState, signaturePad, witnessSignaturePad, resizeAllPads); State.setState({ historyStack: [], historyIndex: -1 }); const { historyIndex, historyStack } = State.getState(); ui.updateUndoRedoButtons(historyIndex, historyStack.length); saveState(); ui.showView('editor-view', onShowEditor, onHideEditor); } function handleFilterClick(e) { if (e.target.matches('.dashboard-filter-button')) { if (e.target.matches('.dashboard-filter-button')) { const newFilter = e.target.dataset.filter; State.setDashboardFilter(newFilter); document.querySelectorAll('.dashboard-filter-button').forEach(btn => btn.classList.remove('active-filter')); e.target.classList.add('active-filter'); applyDashboardFilter(); } } } function handleDashboardCardClick(e) { const target = e.target; const card = target.closest('.estimate-card'); if (!card) return; const estimateId = card.dataset.id; if (target.closest('.card-category-btn')) { ui.openTagModal([estimateId], allEstimates); } else if (target.closest('.add-visit-dashboard-btn')) { ui.openSiteVisitModal(estimateId, allEstimates); } else if (target.closest('.delete-visit-dashboard-btn')) { handleSiteVisitAction(e, estimateId); } else if (target.closest('.complete-visit-dashboard-btn')) { handleCompleteVisit(e, estimateId); } else if (target.closest('h3.font-bold')) { const params = { estimateId, allEstimates, signaturePad, witnessSignaturePad, resizeCanvasForPad: resizeAllPads, saveState, getAppendixDefaultContent, handleRevokeAcceptance, handleSignedCopyDelete, handleShareEstimate: openShareLinkModal, saveAsTemplate, softDeleteEstimate, restoreEstimate, handlePhotoDelete, handleSiteVisitAction, applySketchDataToEstimate, handleSketchDelete, handlePrint, promptAction: (action, id, ids) => ui.promptAction(action, id, ids, allEstimates), updateSnowContractSummary: updateSnowContractSummary, handleDeleteSnowRouteMap: handleDeleteSnowRouteMap, handleSketchDuplicate: handleSketchDuplicate }; ui.loadEstimateForEditing(params); ui.showView('editor-view', onShowEditor, onHideEditor); } } function handleEditorClicks(e) { const target = e.target; if (target.matches('input[type="color"]') || target.matches('input[type="checkbox"]')) { return; } const closestButton = target.closest('button'); const closestLink = target.closest('a'); const closestH3 = target.closest('h3.font-bold'); const closestCategoryBtn = target.closest('.card-category-btn'); const isSnowRouteButton = target.id === 'edit-snow-route-map-btn' || target.id === 'edit-saved-route-map-btn'; const isOtherSnowButton = target.closest('.calculate-snow-price-btn, .apply-snow-summary-btn, .delete-snow-location-btn, .load-from-sketch-btn-single'); if (!closestButton && !closestLink && !closestH3 && !closestCategoryBtn && !isSnowRouteButton && !isOtherSnowButton) { return; } if (target.id === 'edit-ba-map-btn') { const estimateId = document.getElementById('editing-estimate-id').value; const estimate = allEstimates.find(est => est.id === estimateId); if (estimate) { const markers = []; (estimate.beforeAndAfter || []).forEach(pair => { (pair.beforePhotos || []).forEach((photo, index) => { if (photo.location) markers.push({ id: `${pair.id}_before_${index}`, lat: photo.location.lat, lng: photo.location.lng, title: `Before #${index + 1}` }); }); (pair.afterPhotos || []).forEach((photo, index) => { if (photo.location) markers.push({ id: `${pair.id}_after_${index}`, lat: photo.location.lat, lng: photo.location.lng, title: `After #${index + 1}` }); }); }); if (markers.length > 0) { const markersJson = JSON.stringify(markers); const siteAddress = document.getElementById('site-address').value; const customerAddress = document.getElementById('customer-address').value; const addressForMap = siteAddress || customerAddress || estimate.customerInfo?.address; window.location.href = `sketch.html?estimateId=${estimateId}&baMap=true&markers=${encodeURIComponent(markersJson)}&address=${encodeURIComponent(addressForMap)}`; } else { ui.showErrorBanner("No photos with GPS locations were found to edit."); } } return; } if (isSnowRouteButton) { const estimateId = document.getElementById('editing-estimate-id').value; if (!estimateId) return ui.showErrorBanner("Please save the estimate before creating/editing a route."); ui.showSuccessBanner("Generating route data...", true); try { const locationsForMap = []; const allCards = document.querySelectorAll('.snow-location-card'); allCards.forEach(card => { const getVal = (selector) => card.querySelector(selector)?.value || ''; const getNum = (selector) => parseFloat(card.querySelector(selector)?.value) || 0; const address = getVal('.snow-location-address'); if (!address || address.trim() === '') return; const breakdownText = card.querySelector('.snow-calculation-details')?.textContent || ''; const equipmentMatch = breakdownText.match(/Calculated Fleet:\s*(.*?)(?=\s*Volume\/Event:|\s*Cost \/ Push:|\s*$)/i); const timeMatch = breakdownText.match(/(?:On-Site Time|Billable Time):\s*([\d.]+)\s*hrs/i); locationsForMap.push({ id: card.dataset.locationId, address: address, title: getVal('.snow-location-title') || 'Unnamed Location', pricePerPush: getNum('.snow-price-per-push'), priceMonthly: getNum('.snow-price-monthly'), priceSeasonal: getNum('.snow-price-seasonal'), timeToComplete: timeMatch ? parseFloat(timeMatch[1]) : 0, clearingTrigger: getVal('.snow-clearing-trigger'), equipmentInfo: equipmentMatch ? equipmentMatch[1].trim() : 'N/A', sourceSketchId: card.dataset.sourceSketchId || null }); }); if (locationsForMap.length < 2) return ui.showErrorBanner("Please add at least two snow locations with valid addresses to create/edit the route."); if (locationsForMap.some(loc => !loc.address || loc.address.trim() === '')) return ui.showErrorBanner("Please ensure all snow locations have a valid address before creating/editing the map."); const locationsParam = encodeURIComponent(JSON.stringify(locationsForMap)); window.location.href = `sketch.html?estimateId=${estimateId}&snowRoute=true&locations=${locationsParam}`; } catch (error) { console.error("Error preparing snow route data:", error); ui.showErrorBanner(`Could not generate route data: ${error.message}`); } return; } const calculatePriceBtn = target.closest('.calculate-snow-price-btn'); if (calculatePriceBtn) { const card = calculatePriceBtn.closest('.snow-location-card'); handleAutoCalculateSnowPrice(card, true); return; } const applySummaryBtn = target.closest('.apply-snow-summary-btn'); if (applySummaryBtn) { const costType = applySummaryBtn.dataset.costType; applyAllSnowLocationsToOption(costType); return; } const deleteSnowLocationBtn = target.closest('.delete-snow-location-btn'); if (deleteSnowLocationBtn) { if (confirm('Are you sure you want to remove this snow location?')) { const card = deleteSnowLocationBtn.closest('.snow-location-card'); if (card) { card.remove(); handleRouteChange(); } } return; } const loadFromSketchBtn = target.closest('.load-from-sketch-btn-single'); if (loadFromSketchBtn) { const card = loadFromSketchBtn.closest('.snow-location-card'); const estimateId = document.getElementById('editing-estimate-id').value; const estimate = allEstimates.find(e => e.id === estimateId); if (estimate && estimate.sketches && estimate.sketches.length > 0) { ui.openSketchSelectionModal(estimate.sketches, (selectedSketch) => { if (selectedSketch && card) { let totalLoaderArea = 0, totalSkidSteerArea = 0, totalShovelArea = 0; (selectedSketch.measurements || []).forEach(m => { if (m.measurementType === 'area') { if (m.service === 'snow-area-loader') totalLoaderArea += (m.measurement || 0); else if (m.service === 'snow-area-skidsteer') totalSkidSteerArea += (m.measurement || 0); else if (m.service === 'snow-area-shovel') totalShovelArea += (m.measurement || 0); } }); const loaderInput = card.querySelector('.snow-loader-area'); if (loaderInput) loaderInput.value = totalLoaderArea > 0 ? totalLoaderArea.toFixed(2) : ''; const skidSteerInput = card.querySelector('.snow-skidsteer-area'); if (skidSteerInput) skidSteerInput.value = totalSkidSteerArea > 0 ? totalSkidSteerArea.toFixed(2) : ''; const shovelInput = card.querySelector('.snow-shovel-area'); if (shovelInput) shovelInput.value = totalShovelArea > 0 ? totalShovelArea.toFixed(2) : ''; const addressInput = card.querySelector('.snow-location-address'); if (addressInput && selectedSketch.clientAddress) addressInput.value = selectedSketch.clientAddress; card.dataset.sourceSketchId = selectedSketch.id; ui.showSuccessBanner('Snow areas loaded from sketch.'); handleAutoCalculateSnowPrice(card, true); } }); } else { ui.showErrorBanner('No sketches found for this estimate to load from.'); } return; } const addBtn = target.closest('.add-item-btn'); const deleteItemBtn = target.closest('.delete-item-button'); const deleteOptionBtn = target.closest('.delete-option-btn'); const copyOptionBtn = target.closest('.copy-option-btn'); if (target.id === 'add-pricing-option-btn') { ui.addPricingOption(null, saveState); } else if (target.id === 'add-before-after-btn') { ui.addBeforeAfterPair(null, saveState, handlePhotoDelete); } else if (target.id === 'populate-scope-btn') { ui.populateScopeOfWork(saveState); } else if (addBtn) { const optionId = addBtn.closest('.price-option-card')?.dataset.optionId; if (optionId) ui.addItemToOption(optionId, null, false, saveState); } else if (target.id === 'add-item-sketch') { ui.addItemToOption('sketch-card', null, false, saveState); } else if (target.id === 'add-item-change-order') { ui.addItemToOption('change-order-card', null, false, saveState); } else if (deleteItemBtn) { if (confirm('Are you sure you want to remove this line item?')) { deleteItemBtn.closest('.line-item-container').remove(); ui.calculateAllTotals(saveState); saveState(); } } else if (deleteOptionBtn) { if (confirm('Are you sure you want to remove this entire pricing option?')) { deleteOptionBtn.closest('.price-option-card').remove(); ui.calculateAllTotals(saveState); saveState(); } } else if (copyOptionBtn) { console.log("Copy Option button clicked!"); const currentCard = copyOptionBtn.closest('.price-option-card'); if (currentCard) { console.log("Found current card with ID:", currentCard.id, "and dataset ID:", currentCard.dataset.optionId); copyDynamicOption(currentCard, saveState); } else { console.error("Could not find parent .price-option-card for copy button."); } } else if (target.classList.contains('add-ba-photo-btn')) { const pairId = target.dataset.pairId; const type = target.dataset.type; baUploadContext = { pairId, type }; document.getElementById('before-after-photo-input').click(); } } async function handleBeforeAfterUpload(e) { if (!baUploadContext) { console.warn("Before/After upload context is missing."); e.target.value = ''; return; } const { type, pairId } = baUploadContext; const files = Array.from(e.target.files); if (files.length === 0) { baUploadContext = null; e.target.value = ''; return; } const estimateId = document.getElementById('editing-estimate-id').value; if (!estimateId) { ui.showErrorBanner("Please save the estimate before uploading media."); baUploadContext = null; e.target.value = ''; return; } const { storage, ref, uploadBytes, getDownloadURL, db, doc, updateDoc, getDoc } = window.firebaseServices; ui.showSuccessBanner(`Uploading ${files.length} file(s) for ${type}...`, true); try { const uploadPromises = files.map(async (file) => { const location = await getGPSLocation(file); const fileRef = ref(storage, `estimates/${estimateId}/before-after/${pairId}_${type}_${Date.now()}_${file.name}`); const snapshot = await uploadBytes(fileRef, file); const url = await getDownloadURL(snapshot.ref); const fileType = file.type.startsWith('video/') ? 'video' : 'image'; return { url, type: fileType, location }; }); const newMediaObjects = await Promise.all(uploadPromises); const estimateRef = doc(db, 'estimates', estimateId); const estimateSnap = await getDoc(estimateRef); if (!estimateSnap.exists()) { throw new Error("Estimate document not found in Firestore."); } const estimateData = estimateSnap.data(); let currentPairs = JSON.parse(JSON.stringify(estimateData.beforeAndAfter || [])); let pairToUpdate = currentPairs.find(p => p.id === pairId); if (!pairToUpdate) { const pairDiv = document.querySelector(`.before-after-pair[data-pair-id="${pairId}"]`); if (pairDiv) { const title = pairDiv.querySelector('.ba-title-input')?.value || 'New Showcase'; const allQuillInstances = ui.getQuillInstance(); const description = allQuillInstances[pairId] ? allQuillInstances[pairId].root.innerHTML : ''; const newPair = { id: pairId, title, description, beforePhotos: [], afterPhotos: [] }; currentPairs.push(newPair); pairToUpdate = newPair; } else { throw new Error(`Could not find Before & After pair with ID: ${pairId} in data or UI.`); } } if (type === 'before') { pairToUpdate.beforePhotos = [...(pairToUpdate.beforePhotos || []), ...newMediaObjects]; } else { pairToUpdate.afterPhotos = [...(pairToUpdate.afterPhotos || []), ...newMediaObjects]; } await updateDoc(estimateRef, { beforeAndAfter: currentPairs }); const localEstimate = allEstimates.find(est => est.id === estimateId); if (localEstimate) { localEstimate.beforeAndAfter = currentPairs; } ui.renderBeforeAndAfter(currentPairs, saveState, handlePhotoDelete); saveState(); ui.showSuccessBanner("Upload complete!"); } catch (error) { console.error("Error uploading Before & After media:", error); ui.showErrorBanner(`An error occurred during upload: ${error.message}`); } finally { baUploadContext = null; e.target.value = ''; } } function handleNewSketchFromEditor() { const estimateId = document.getElementById('editing-estimate-id').value; if (estimateId) { const siteAddress = document.getElementById('site-address').value; const customerAddress = document.getElementById('customer-address').value; const address = siteAddress || customerAddress; window.location.href = `sketch.html?estimateId=${estimateId}&address=${encodeURIComponent(address)}`; } else { ui.showErrorBanner("Please save this estimate before adding a sketch."); } } function handleSketchForExisting(e) { const selectedId = e.target.value; if (selectedId) { const estimate = allEstimates.find(est => est.id === selectedId); const siteAddress = estimate?.customerInfo?.siteAddress; const customerAddress = estimate?.customerInfo?.address; const address = siteAddress || customerAddress || ''; window.location.href = `sketch.html?estimateId=${selectedId}&address=${encodeURIComponent(address)}`; } } function saveState() { const { isApplyingHistory, historyStack, historyIndex } = State.getState(); if (isApplyingHistory || window.isLoading) { return; } let currentStateData; try { currentStateData = getEstimateDataForSave(); } catch (error) { console.error("Error getting data for saveState:", error); return; } const currentStateString = JSON.stringify(currentStateData); if (historyStack.length > 0 && historyStack[historyStack.length - 1] === currentStateString) { return; } State.pushHistory(currentStateString); const newState = State.getState(); ui.updateUndoRedoButtons(newState.historyIndex, newState.historyStack.length); } function applyState(stateDataString) { isApplyingHistory = true; try { const data = JSON.parse(stateDataString); const estimateId = data.id || document.getElementById('editing-estimate-id').value; if (!estimateId) { console.error("Cannot apply state: Estimate ID is missing."); return; } const tempEstimate = { id: estimateId, ...data }; const currentEstimates = State.getState().estimates; const existingIndex = currentEstimates.findIndex(e => e.id === estimateId); if (existingIndex > -1) { State.updateEstimate(tempEstimate); } else { State.addEstimate(tempEstimate); } const allEstimates = State.getState().estimates; const params = { estimateId: estimateId, allEstimates: allEstimates, signaturePad: signaturePad, witnessSignaturePad: witnessSignaturePad, resizeCanvasForPad: resizeAllPads, saveState: saveState, getAppendixDefaultContent: getAppendixDefaultContent, handleRevokeAcceptance: handleRevokeAcceptance, handleSignedCopyDelete: handleSignedCopyDelete, handleShareEstimate: openShareLinkModal, saveAsTemplate: saveAsTemplate, softDeleteEstimate: softDeleteEstimate, restoreEstimate: restoreEstimate, handlePhotoDelete: handlePhotoDelete, handleSiteVisitAction: handleSiteVisitAction, applySketchDataToEstimate: applySketchDataToEstimate, handleSketchDelete: handleSketchDelete, handlePrint: handlePrint, promptAction: (action, id, ids) => ui.promptAction(action, id, ids, allEstimates), updateSnowContractSummary: updateSnowContractSummary }; ui.loadEstimateForEditing(params); } catch (e) { console.error("Failed to parse or apply state:", e); ui.showErrorBanner("Error applying undo/redo state."); } finally { isApplyingHistory = false; } } function undo() { const previousState = State.undo(); if (previousState) { applyState(previousState); const { historyIndex, historyStack } = State.getState(); ui.updateUndoRedoButtons(historyIndex, historyStack.length); } } function redo() { const nextState = State.redo(); if (nextState) { applyState(nextState); const { historyIndex, historyStack } = State.getState(); ui.updateUndoRedoButtons(historyIndex, historyStack.length); } } let estimatesUnsubscribe = null; let currentLimit = 50; function listenForEstimates() { const { db, collection, onSnapshot, query, orderBy, limit } = window.firebaseServices; if (estimatesUnsubscribe) { estimatesUnsubscribe(); } const q = query(collection(db, "estimates"), orderBy("lastSaved", "desc"), limit(currentLimit)); estimatesUnsubscribe = onSnapshot(q, (snapshot) => { const estimates = snapshot.docs.map(d => ({ id: d.id, ...d.data() })); State.setEstimates(estimates); const loadMoreContainer = document.getElementById('load-more-container'); if (loadMoreContainer) { if (snapshot.docs.length < currentLimit) { loadMoreContainer.classList.add('hidden'); } else { loadMoreContainer.classList.remove('hidden'); } } const { initialLoadComplete, estimates: allEstimates } = State.getState(); let openedDeepLink = false; if (!initialLoadComplete && deepLinkTarget) { const estimateToLoad = allEstimates.find(e => e.id === deepLinkTarget.id); if (estimateToLoad) { const params = { estimateId: deepLinkTarget.id, allEstimates, signaturePad, witnessSignaturePad, resizeCanvasForPad: resizeAllPads, saveState, getAppendixDefaultContent, handleRevokeAcceptance, handleSignedCopyDelete, handleShareEstimate: openShareLinkModal, saveAsTemplate, softDeleteEstimate, restoreEstimate, handlePhotoDelete, handleSiteVisitAction, applySketchDataToEstimate, handleSketchDelete, handlePrint, promptAction: (action, id, ids) => ui.promptAction(action, id, ids, allEstimates), updateSnowContractSummary: updateSnowContractSummary, handleDeleteSnowRouteMap: handleDeleteSnowRouteMap, handleSketchDuplicate: handleSketchDuplicate }; ui.loadEstimateForEditing(params); ui.showView('editor-view', onShowEditor, onHideEditor); openedDeepLink = true; setTimeout(() => { if (deepLinkTarget && deepLinkTarget.section) { let elementId; if (deepLinkTarget.section === 'before-after') { elementId = 'print-section-before-after'; } else if (deepLinkTarget.section === 'sketches') { elementId = 'print-section-sketches'; } else if (deepLinkTarget.section === 'snow-routes' || deepLinkTarget.section === 'snow') { elementId = 'multi-site-snow-section'; } const element = document.getElementById(elementId); if (element) { element.scrollIntoView({ behavior: 'smooth', block: 'start' }); } } deepLinkTarget = null; }, 500); } else { ui.showErrorBanner(`Deep link error: Could not find estimate with ID: ${deepLinkTarget.id}`); deepLinkTarget = null; if (document.getElementById('dashboard-view').classList.contains('active')) { applyDashboardFilter(); } } } if (!openedDeepLink && document.getElementById('dashboard-view').classList.contains('active')) { applyDashboardFilter(); } ui.populateTemplateDropdown(allEstimates); State.setState({ initialLoadComplete: true }); if (deepLinkTarget && !openedDeepLink) { deepLinkTarget = null; } }, (error) => { console.error("Error listening for estimates:", error); ui.showErrorBanner("Could not fetch estimates. Check connection and Firestore rules."); } ); } function applyDashboardFilter() { const { estimates: allEstimates, dashboardFilter: currentDashboardFilter } = State.getState(); let list = []; const isParked = (e) => ['Deferred (Next Season)', 'Inactive', 'Declined'].includes(e.status); if (currentDashboardFilter === 'templates') { list = allEstimates.filter(e => e.status === 'Template'); } else if (currentDashboardFilter === 'deleted') { list = allEstimates.filter(e => e.isDeleted === true); } else if (currentDashboardFilter === 'parked') { list = allEstimates.filter(e => !e.isDeleted && isParked(e)); } else if (currentDashboardFilter === 'all') { list = allEstimates.filter(e => e.status !== 'Template' && !e.isDeleted && !isParked(e)); } else { list = allEstimates.filter(e => e.status !== 'Template' && !e.isDeleted && !isParked(e) && e.tags?.includes(currentDashboardFilter) ); } const term = document.getElementById('dashboard-search-input').value.toLowerCase(); if (term) { list = allEstimates.filter(e => e.status !== 'Template' && !e.isDeleted && JSON.stringify(e).toLowerCase().includes(term) ); } list.sort((a, b) => new Date(b.lastSaved || 0) - new Date(a.lastSaved || 0)); ui.renderDashboard( list, currentDashboardFilter, getSelectedIds, planRoute, (ids) => ui.openCategoryModal(ids, allEstimates), (action, id, ids) => ui.promptAction(action, id, ids, allEstimates) ); ui.renderSalesSchedule(allEstimates); } function handleSelectAll(e) { document.querySelectorAll('.item-select-checkbox').forEach(cb => cb.checked = e.target.checked); const { estimates: allEstimates, dashboardFilter: currentDashboardFilter } = State.getState(); ui.updateBatchActionBar( currentDashboardFilter, getSelectedIds, planRoute, (ids) => ui.openCategoryModal(ids, allEstimates), (action, id, ids) => ui.promptAction(action, id, ids, allEstimates), (ids) => ui.openRoutePlannerModal(ids, allEstimates) ); } function handleDashboardCardChange(e) { if (e.target.classList.contains('item-select-checkbox')) { const { estimates: allEstimates, dashboardFilter: currentDashboardFilter } = State.getState(); ui.updateBatchActionBar( currentDashboardFilter, getSelectedIds, planRoute, (ids) => ui.openCategoryModal(ids, allEstimates), (action, id, ids) => ui.promptAction(action, id, ids, allEstimates), (ids) => ui.openRoutePlannerModal(ids, allEstimates) ); } else if (e.target.classList.contains('dashboard-status-select')) { handleDashboardStatusChange(e.target.dataset.id, e.target.value); } else if (e.target.classList.contains('visit-date-input') || e.target.classList.contains('visit-time-input')) { handleDashboardVisitChange(e); } } function onShowEditor() { if (!autosaveInterval) { autosaveInterval = setInterval(() => saveEstimate(getEstimateDataForSave, true), 30000); } resizeAllPads(); } function onHideEditor() { if (autosaveInterval) { clearInterval(autosaveInterval); autosaveInterval = null; } } function getEstimateDataForSave() { return getEstimateData(ui.getQuillInstance(), signaturePad, witnessSignaturePad); } function getAppendixDefaultContent() { return `<h3>Our Project Process: A Simple Overview</h3> <p><strong>1. Preparation & Excavation:</strong> Site is prepared, and existing materials may be removed. Excavation to the required depth occurs if necessary.</p> <p><strong>2. Base Installation:</strong> Geotextile fabric may be laid, followed by the placement and compaction of granular base material to ensure a stable foundation.</p> <p><strong>3. Paving/Installation:</strong> Asphalt or concrete is placed, graded, and finished according to the specifications.</p> <p><strong>4. Cleanup:</strong> The work area is cleaned of debris upon completion.</p> <p><em>(Note: Specific steps may vary based on the project scope.)</em></p>`; } function resizeAllPads() { const resizeCanvasForPad = (canvas, pad) => { if (!canvas || !pad || canvas.offsetWidth === 0) return; const ratio = Math.max(window.devicePixelRatio || 1, 1); const data = pad.toData(); canvas.width = canvas.offsetWidth * ratio; canvas.height = canvas.offsetHeight * ratio; canvas.getContext("2d").scale(ratio, ratio); pad.clear(); pad.fromData(data); }; resizeCanvasForPad(document.getElementById('signature-pad'), signaturePad); resizeCanvasForPad(document.getElementById('witness-signature-pad-editor'), witnessSignaturePad); } function handleDeleteConfirmation(e) { const button = e.target; const { action, id, ids } = button.dataset; const idList = ids ? ids.split(',') : (id ? [id] : []); switch (action) { case 'deletePermanent': if (id) deleteFirestoreDoc(id); break; case 'duplicate': if (id) duplicateEstimate(id); break; case 'batchDelete': idList.forEach(deleteFirestoreDoc); break; case 'batchSoftDelete': idList.forEach(softDeleteEstimate); break; case 'batchRestore': idList.forEach(restoreEstimate); break; case 'saveAppendixToAll': updateAllEstimatesContent('appendix'); break; case 'saveTermsToAll': updateAllEstimatesContent('terms'); break; default: console.warn("Unknown action in handleDeleteConfirmation:", action); break; } ui.hideDeleteModal(); } async function deleteFirestoreDoc(estimateId) { if (!estimateId) { console.warn("Attempted to delete without an estimate ID."); return; } const { db, doc, deleteDoc } = window.firebaseServices; try { ui.showSuccessBanner(`Permanently deleting item ${estimateId}...`, true); await deleteDoc(doc(db, "estimates", estimateId)); const allEstimates = State.getState().estimates; const index = allEstimates.findIndex(e => e.id === estimateId); if (index > -1) { const newEstimates = [...allEstimates]; newEstimates.splice(index, 1); State.setEstimates(newEstimates); } if (document.getElementById('dashboard-view').classList.contains('active')) { applyDashboardFilter(); } ui.showSuccessBanner(`Item ${estimateId} permanently deleted.`); } catch (error) { console.error(`Error permanently deleting estimate ${estimateId}:`, error); ui.showErrorBanner(`Could not permanently delete item: ${error.message}`); } } async function duplicateEstimate(estimateId) { if (!estimateId) { console.warn("Attempted to duplicate without an estimate ID."); return; } const { db, collection, addDoc } = window.firebaseServices; const originalEstimate = State.getState().estimates.find(e => e.id === estimateId); if (!originalEstimate) { ui.showErrorBanner("Could not find the original estimate data to duplicate."); return; } try { ui.showSuccessBanner("Duplicating estimate...", true); let duplicatedData = JSON.parse(JSON.stringify(originalEstimate)); delete duplicatedData.id; duplicatedData.customerInfo = duplicatedData.customerInfo || {}; duplicatedData.customerInfo.name = `${originalEstimate.customerInfo?.name || 'Estimate'} (Copy)`; duplicatedData.createdAt = new Date().toISOString(); duplicatedData.lastSaved = new Date().toISOString(); duplicatedData.status = 'Draft'; duplicatedData.isDeleted = false; delete duplicatedData.acceptance; delete duplicatedData.customerNotes; delete duplicatedData.siteVisits; delete duplicatedData.workStages; await addDoc(collection(db, 'estimates'), duplicatedData); ui.showSuccessBanner("Estimate duplicated successfully."); } catch (error) { console.error(`Error duplicating estimate ${estimateId}:`, error); ui.showErrorBanner(`Could not duplicate estimate: ${error.message}`); } } async function handleDashboardStatusChange(estimateId, newStatus) { if (!estimateId || !newStatus) { console.warn("Missing estimateId or newStatus for status change."); return; } const { db, doc, updateDoc } = window.firebaseServices; try { const estimateData = allEstimates.find(e => e.id === estimateId); if (!estimateData) { ui.showErrorBanner("Could not find estimate data to update status."); return; } const updatedDataWithTags = updateTagsBasedOnData({ ...estimateData, status: newStatus }); const newTags = updatedDataWithTags.tags; const updatePayload = { status: newStatus, tags: newTags, lastSaved: new Date().toISOString() }; const estimateRef = doc(db, 'estimates', estimateId); await updateDoc(estimateRef, updatePayload); if (estimateData) { estimateData.status = newStatus; estimateData.tags = newTags; estimateData.lastSaved = updatePayload.lastSaved; } if (document.getElementById('dashboard-view').classList.contains('active')) { applyDashboardFilter(); } ui.showSuccessBanner('Status updated successfully.'); } catch (e) { console.error("Error updating estimate status from dashboard:", e); ui.showErrorBanner(`Could not update status: ${e.message}`); } } async function handleDashboardVisitChange(e) { const { db, doc, updateDoc } = window.firebaseServices; const { estimateId, visitIndex } = e.target.dataset; const index = parseInt(visitIndex, 10); if (!estimateId || isNaN(index)) { console.warn("Missing estimateId or visitIndex for dashboard visit change."); return; } const estimate = allEstimates.find(est => est.id === estimateId); if (!estimate || !estimate.siteVisits || index < 0 || index >= estimate.siteVisits.length) { ui.showErrorBanner("Could not find the visit data to update."); return; } let updatedVisits = JSON.parse(JSON.stringify(estimate.siteVisits)); if (e.target.classList.contains('visit-date-input')) { updatedVisits[index].date = e.target.value; } else if (e.target.classList.contains('visit-time-input')) { updatedVisits[index].time = e.target.value; } else { return; } try { await updateDoc(doc(db, 'estimates', estimateId), { siteVisits: updatedVisits, lastSaved: new Date().toISOString() }); estimate.siteVisits = updatedVisits; estimate.lastSaved = new Date().toISOString(); ui.showSuccessBanner('Visit details updated.'); } catch (error) { console.error("Error updating visit from dashboard:", error); ui.showErrorBanner(`Could not update visit: ${error.message}`); } } async function handleRevokeAcceptance() { const estimateId = document.getElementById('editing-estimate-id').value; if (!estimateId || !confirm("Are you sure you want to revoke this acceptance? This will clear the signatures and acceptance date.")) { return; } const { db, doc, updateDoc } = window.firebaseServices; try { ui.showSuccessBanner("Revoking acceptance...", true); const updatePayload = { acceptance: { signedCopyURL: allEstimates.find(e => e.id === estimateId)?.acceptance?.signedCopyURL || null, signatureDataURL: null, witnessSignatureDataURL: null, acceptanceDate: '', printedName: '', witnessPrintedName: '' }, status: 'Sent' }; await updateDoc(doc(db, 'estimates', estimateId), updatePayload); const estimate = allEstimates.find(e => e.id === estimateId); if (estimate) { estimate.acceptance = updatePayload.acceptance; estimate.status = updatePayload.status; } document.getElementById('signature-pad-wrapper').classList.remove('hidden'); document.getElementById('signed-view-wrapper').classList.add('hidden'); if (signaturePad) signaturePad.clear(); if (witnessSignaturePad) witnessSignaturePad.clear(); const printNameInput = document.getElementById('editor-print-name'); const witnessPrintNameInput = document.getElementById('editor-witness-print-name'); const acceptanceDateInput = document.getElementById('acceptance-date'); if (printNameInput) printNameInput.value = ''; if (witnessPrintNameInput) witnessPrintNameInput.value = ''; if (acceptanceDateInput) acceptanceDateInput.value = ''; const statusDropdown = document.getElementById('estimate-status'); if (statusDropdown) statusDropdown.value = 'Sent'; saveState(); ui.showSuccessBanner('Acceptance has been revoked.'); } catch (error) { console.error("Error revoking acceptance:", error); ui.showErrorBanner(`Could not revoke acceptance: ${error.message}`); } } async function handleSignedCopyDelete() { const estimateId = document.getElementById('editing-estimate-id').value; if (!estimateId || !confirm("Are you sure you want to permanently delete the uploaded signed document? This cannot be undone.")) { return; } const { storage, ref, deleteObject, db, doc, updateDoc } = window.firebaseServices; const estimate = allEstimates.find(e => e.id === estimateId); const signedCopyURL = estimate?.acceptance?.signedCopyURL; if (!signedCopyURL) { ui.showErrorBanner("No uploaded signed document found to delete."); return; } try { ui.showSuccessBanner("Deleting document...", true); const fileRef = ref(storage, signedCopyURL); await deleteObject(fileRef); await updateDoc(doc(db, 'estimates', estimateId), { 'acceptance.signedCopyURL': null }); if (estimate && estimate.acceptance) { estimate.acceptance.signedCopyURL = null; } const signedCopyContainer = document.getElementById('signed-copy-link-container'); if (signedCopyContainer) { signedCopyContainer.innerHTML = '<p class="text-xs text-gray-500">No document uploaded.</p>'; } saveState(); ui.showSuccessBanner('Uploaded signed document deleted successfully.'); } catch (error) { console.error("Error deleting signed copy:", error); if (error.code === 'storage/object-not-found') { ui.showErrorBanner("File already deleted from storage. Updating estimate record..."); try { await updateDoc(doc(db, 'estimates', estimateId), { 'acceptance.signedCopyURL': null }); if (estimate && estimate.acceptance) estimate.acceptance.signedCopyURL = null; const signedCopyContainer = document.getElementById('signed-copy-link-container'); if (signedCopyContainer) signedCopyContainer.innerHTML = '<p class="text-xs text-gray-500">No document uploaded.</p>'; saveState(); } catch (dbError) { ui.showErrorBanner("Could not update the estimate record after storage error."); } } else { ui.showErrorBanner(`Could not delete the document: ${error.message}`); } } } async function openShareLinkModal(estimateId) { const { db, collection, query, where, getDocs, addDoc, doc, updateDoc, getDoc, onSnapshot } = window.firebaseServices; const modal = document.getElementById('share-link-modal'); const content = document.getElementById('share-modal-content'); const loader = document.getElementById('share-modal-loader'); const statusEl = document.getElementById('share-link-status'); const linkInput = document.getElementById('share-link-input'); const toggleBtn = document.getElementById('toggle-link-active-btn'); const copyBtn = document.getElementById('copy-share-link-btn'); const closeBtn = document.getElementById('close-share-modal-btn'); const historyContainer = document.getElementById('view-history-container'); let unsubscribeHistory = null; modal.classList.remove('hidden'); content.classList.add('hidden'); loader.classList.remove('hidden'); loader.innerHTML = '<p>Loading link information...</p>'; historyContainer.innerHTML = '<p class="text-gray-500">Loading view history...</p>'; toggleBtn.onclick = null; copyBtn.onclick = null; closeBtn.onclick = null; try { const linksCollection = collection(db, 'sharedLinks'); const q = query(linksCollection, where("estimateId", "==", estimateId)); const linkSnap = await getDocs(q); let linkDocRef; let token; let linkData; if (linkSnap.empty) { token = `token_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`; linkData = { estimateId, token, isActive: true, createdAt: new Date() }; const newLinkDoc = await addDoc(linksCollection, linkData); linkDocRef = newLinkDoc; console.log("Created new share link."); } else { linkDocRef = linkSnap.docs[0].ref; linkData = linkSnap.docs[0].data(); token = linkData.token; console.log("Found existing share link."); } const fullLink = `${window.location.origin}/client-portal.html?token=${token}`; linkInput.value = fullLink; const updateUI = (currentLinkData) => { if (!currentLinkData) return; if (currentLinkData.isActive) { statusEl.textContent = 'Active'; statusEl.className = 'text-xs font-bold py-1 px-3 rounded-full bg-green-100 text-green-800'; toggleBtn.textContent = 'Deactivate Link'; toggleBtn.className = 'rounded-md bg-red-600 px-4 py-2 text-sm font-medium text-white hover:bg-red-700'; } else { statusEl.textContent = 'Inactive'; statusEl.className = 'text-xs font-bold py-1 px-3 rounded-full bg-gray-200 text-gray-800'; toggleBtn.textContent = 'Activate Link'; toggleBtn.className = 'rounded-md bg-green-600 px-4 py-2 text-sm font-medium text-white hover:bg-green-700'; } }; const renderViewHistory = (views) => { historyContainer.innerHTML = ''; if (!views || views.length === 0) { historyContainer.innerHTML = '<p class="text-gray-500">No views recorded yet.</p>'; return; } views.sort((a, b) => b.timestamp.seconds - a.timestamp.seconds); views.forEach(view => { const viewEl = document.createElement('div'); viewEl.className = 'p-2 bg-gray-50 rounded-md border text-xs mb-2'; const date = new Date(view.timestamp.seconds * 1000).toLocaleString(); let identityHtml = ''; if (view.viewerEmail) { identityHtml = `<p class="font-bold text-blue-600">${view.viewerName || 'Unknown Name'} (${view.viewerEmail})</p>`; } else { identityHtml = `<p class="font-semibold text-gray-600">Anonymous / Unverified</p>`; } let referrerInfo = 'Accessed directly or via private channel'; if (view.referrer && !view.referrer.startsWith(window.location.origin) && view.referrer !== "Direct link") { try { const url = new URL(view.referrer); referrerInfo = `Referred from ${url.hostname}`; } catch { referrerInfo = `Referred from ${view.referrer}`; } } viewEl.innerHTML = `${identityHtml}<p class="text-gray-500">${date}</p><p class="text-gray-400 italic">${referrerInfo}</p>`; historyContainer.appendChild(viewEl); }); }; const viewsCollection = collection(linkDocRef, 'linkViews'); if (unsubscribeHistory) unsubscribeHistory(); unsubscribeHistory = onSnapshot(viewsCollection, (snapshot) => { const views = snapshot.docs.map(doc => doc.data()); renderViewHistory(views); }, (error) => { console.error("Error listening to view history:", error); historyContainer.innerHTML = '<p class="text-red-500 text-xs">Could not load view history.</p>'; }); toggleBtn.onclick = async () => { toggleBtn.disabled = true; try { const currentDoc = await getDoc(linkDocRef); const currentState = currentDoc.data().isActive; await updateDoc(linkDocRef, { isActive: !currentState }); updateUI({ isActive: !currentState }); } catch (error) { console.error("Error toggling link status:", error); ui.showErrorBanner("Could not update link status."); } finally { toggleBtn.disabled = false; } }; copyBtn.onclick = () => { navigator.clipboard.writeText(fullLink).then(() => { ui.showSuccessBanner("Link copied to clipboard!"); }, (err) => { console.error('Failed to copy link: ', err); ui.showErrorBanner("Could not copy link. Check browser permissions."); }); }; closeBtn.onclick = () => { modal.classList.add('hidden'); if (unsubscribeHistory) { unsubscribeHistory(); unsubscribeHistory = null; } }; updateUI(linkData); loader.classList.add('hidden'); content.classList.remove('hidden'); } catch (error) { console.error("Error opening share link modal:", error); loader.innerHTML = `<p class="text-red-600 font-semibold">Error loading link: ${error.message}</p>`; const errorCloseBtn = document.createElement('button'); errorCloseBtn.textContent = 'Close'; errorCloseBtn.className = 'mt-4 rounded-md bg-gray-200 px-4 py-2 text-sm font-medium text-gray-800 hover:bg-gray-300'; errorCloseBtn.onclick = () => { modal.classList.add('hidden'); if (unsubscribeHistory) { unsubscribeHistory(); unsubscribeHistory = null; } }; loader.appendChild(errorCloseBtn); } } async function saveAsTemplate() { const templateName = prompt("Enter a name for this template:"); if (!templateName || templateName.trim() === "") { return; } const { db, collection, addDoc } = window.firebaseServices; try { ui.showSuccessBanner("Saving as template...", true); let templateData = getEstimateDataForSave(); let newTemplate = JSON.parse(JSON.stringify(templateData)); delete newTemplate.id; delete newTemplate.customerInfo; delete newTemplate.acceptance; delete newTemplate.customerNotes; delete newTemplate.siteVisits; delete newTemplate.workStages; delete newTemplate.sketches; delete newTemplate.beforeAndAfter; delete newTemplate.workPhotos; delete newTemplate.propertyPhotoURL; delete newTemplate.contactHistory; delete newTemplate.leadRating; delete newTemplate.sharingOptions; delete newTemplate.snowLocations; delete newTemplate.snowRouteOrder; delete newTemplate.createdAt; delete newTemplate.lastSaved; delete newTemplate.isDeleted; if (newTemplate.financialSummary) { const fieldsToKeep = ['interestRate']; for (const key in newTemplate.financialSummary) { if (!fieldsToKeep.includes(key)) { newTemplate.financialSummary[key] = ''; } } } newTemplate.status = 'Template'; newTemplate.templateName = templateName.trim(); newTemplate.tags = []; await addDoc(collection(db, 'estimates'), newTemplate); ui.showSuccessBanner(`Template "${templateName.trim()}" saved successfully.`); } catch (error) { console.error("Error saving template:", error); ui.showErrorBanner(`Could not save the template: ${error.message}`); } } async function softDeleteEstimate(estimateId) { if (!estimateId || !confirm("Are you sure you want to move this estimate to the Deleted tab?")) { return; } const { db, doc, updateDoc } = window.firebaseServices; try { ui.showSuccessBanner("Moving estimate to Deleted...", true); await updateDoc(doc(db, 'estimates', estimateId), { isDeleted: true, lastSaved: new Date().toISOString() }); const estimate = State.getState().estimates.find(e => e.id === estimateId); if (estimate) { estimate.isDeleted = true; estimate.lastSaved = new Date().toISOString(); State.updateEstimate(estimate); } if (document.getElementById('editor-view').classList.contains('active') && document.getElementById('editing-estimate-id').value === estimateId) { ui.showView('dashboard-view', onShowEditor, onHideEditor); } else if (document.getElementById('dashboard-view').classList.contains('active')) { applyDashboardFilter(); } ui.showSuccessBanner("Estimate moved to Deleted successfully."); } catch (error) { console.error("Error soft deleting estimate:", error); ui.showErrorBanner(`Could not move estimate to Deleted: ${error.message}`); } } async function restoreEstimate(estimateId) { if (!estimateId) { ui.showErrorBanner("Cannot restore: Estimate ID is missing."); return; } const { db, doc, updateDoc } = window.firebaseServices; try { ui.showSuccessBanner("Restoring estimate...", true); await updateDoc(doc(db, 'estimates', estimateId), { isDeleted: false, lastSaved: new Date().toISOString() }); const estimate = State.getState().estimates.find(e => e.id === estimateId); if (estimate) { estimate.isDeleted = false; estimate.lastSaved = new Date().toISOString(); State.updateEstimate(estimate); } if (document.getElementById('dashboard-view').classList.contains('active')) { applyDashboardFilter(); } ui.showSuccessBanner("Estimate restored successfully."); } catch (error) { console.error("Error restoring estimate:", error); ui.showErrorBanner(`Could not restore estimate: ${error.message}`); } } async function handlePhotoDelete(type, data) { const estimateId = document.getElementById('editing-estimate-id').value; if (!estimateId) { ui.showErrorBanner("Cannot delete media from an unsaved estimate."); return; } if (!confirm("Are you sure you want to permanently delete this media?")) { return; } const { storage, ref, deleteObject, db, doc, updateDoc } = window.firebaseServices; const estimate = allEstimates.find(e => e.id === estimateId); if (!estimate) { ui.showErrorBanner("Could not find the current estimate data."); return; } let updatePayload = {}; let shouldRerenderBA = false; try { ui.showSuccessBanner("Deleting media...", true); if (type === 'property') { if (!estimate.propertyPhotoURL) return; await deleteObject(ref(storage, estimate.propertyPhotoURL)); updatePayload.propertyPhotoURL = null; } else if (type === 'work') { if (!estimate.workPhotos || !data.url) return; await deleteObject(ref(storage, data.url)); updatePayload.workPhotos = estimate.workPhotos.filter(p => p.url !== data.url); } else if (type === 'before-after' || type === 'before-after-pair') { shouldRerenderBA = true; const currentPairs = JSON.parse(JSON.stringify(estimate.beforeAndAfter || [])); let pairsToUpdate = []; if (type === 'before-after') { await deleteObject(ref(storage, data.url)); pairsToUpdate = currentPairs.map(pair => { if (pair.id === data.pairId) { if (data.type === 'before') { pair.beforePhotos = (pair.beforePhotos || []).filter(media => media.url !== data.url); } else { pair.afterPhotos = (pair.afterPhotos || []).filter(media => media.url !== data.url); } } return pair; }); } else { const pairToDelete = currentPairs.find(p => p.id === data.pairData.id); if (pairToDelete) { const mediaToDelete = [...(pairToDelete.beforePhotos || []), ...(pairToDelete.afterPhotos || [])]; const deletePromises = mediaToDelete.map(media => { if (media.url) return deleteObject(ref(storage, media.url)); return Promise.resolve(); }); await Promise.all(deletePromises); } pairsToUpdate = currentPairs.filter(p => p.id !== data.pairData.id); } updatePayload.beforeAndAfter = pairsToUpdate; } await updateDoc(doc(db, 'estimates', estimateId), updatePayload); if (updatePayload.beforeAndAfter !== undefined) estimate.beforeAndAfter = updatePayload.beforeAndAfter; if (updatePayload.propertyPhotoURL !== undefined) estimate.propertyPhotoURL = updatePayload.propertyPhotoURL; if (updatePayload.workPhotos) estimate.workPhotos = updatePayload.workPhotos; if (type === 'property') ui.renderPropertyPhoto(null, estimate.customerInfo?.address, handlePhotoDelete); if (type === 'work') ui.renderWorkPhotos(estimate.workPhotos, handlePhotoDelete); if (shouldRerenderBA) ui.renderBeforeAndAfter(estimate.beforeAndAfter, saveState, handlePhotoDelete); saveState(); ui.showSuccessBanner("Media deleted successfully."); } catch (error) { console.error("Error deleting photo:", error); if (error.code === 'storage/object-not-found') { ui.showErrorBanner("File was already deleted from storage. Updating record..."); try { await updateDoc(doc(db, 'estimates', estimateId), updatePayload); if (shouldRerenderBA) ui.renderBeforeAndAfter(updatePayload.beforeAndAfter, saveState, handlePhotoDelete); } catch (dbError) { ui.showErrorBanner("Could not update the estimate record."); } } else { ui.showErrorBanner("Could not delete media. Please check console for details."); } } } async function handleDeleteSnowRouteMap(estimateId) { if (!estimateId || !confirm("Are you sure you want to delete the saved snow route map and order? This cannot be undone.")) { return; } const { db, doc, updateDoc } = window.firebaseServices; try { ui.showSuccessBanner("Deleting snow route map...", true); await updateDoc(doc(db, 'estimates', estimateId), { snowRouteMapUrl: null, snowRouteOrder: [], lastSaved: new Date().toISOString() }); const estimate = allEstimates.find(e => e.id === estimateId); if (estimate) { estimate.snowRouteMapUrl = null; estimate.snowRouteOrder = []; estimate.lastSaved = new Date().toISOString(); } ui.hideSnowRoutePreview(); saveState(); ui.showSuccessBanner("Snow route map deleted successfully."); } catch (error) { console.error("Error deleting snow route map:", error); ui.showErrorBanner(`Could not delete snow route map: ${error.message}`); } } async function handleSiteVisitAction(e, estimateIdFromCard = null) { const { db, doc, updateDoc } = window.firebaseServices; const estimateId = document.getElementById('editing-estimate-id').value || estimateIdFromCard; if (!estimateId) { ui.showErrorBanner("Could not identify the estimate for this action."); return; } const targetButton = e.target.closest('.remove-visit-button, .reschedule-btn, .delete-visit-dashboard-btn'); const rawIndex = targetButton ? (targetButton.dataset.index || targetButton.dataset.visitIndex) : null; if (!targetButton || rawIndex === undefined || rawIndex === null) { console.warn("Could not find visit index from clicked element:", e.target); return; } const visitIndex = parseInt(rawIndex, 10); const estimate = allEstimates.find(est => est.id === estimateId); if (!estimate || !estimate.siteVisits || visitIndex < 0 || visitIndex >= estimate.siteVisits.length) { ui.showErrorBanner("Could not find the visit data to modify."); return; } if (targetButton.classList.contains('remove-visit-button') || targetButton.classList.contains('delete-visit-dashboard-btn')) { if (!confirm('Are you sure you want to remove this site visit?')) { return; } let updatedVisits = [...estimate.siteVisits]; updatedVisits.splice(visitIndex, 1); try { ui.showSuccessBanner("Removing visit...", true); await updateDoc(doc(db, 'estimates', estimateId), { siteVisits: updatedVisits }); estimate.siteVisits = updatedVisits; if (document.getElementById('editor-view').classList.contains('active') && document.getElementById('editing-estimate-id').value === estimateId) { ui.populateSiteVisitsEditor(estimateId, updatedVisits, allEstimates, handleSiteVisitAction); } if (document.getElementById('dashboard-view').classList.contains('active')) { applyDashboardFilter(); } ui.showSuccessBanner('Site visit removed.'); saveState(); } catch (err) { console.error("Error removing site visit:", err); ui.showErrorBanner('Could not remove the site visit.'); } } else if (targetButton.classList.contains('reschedule-btn')) { ui.openSiteVisitModal(estimateId, allEstimates, visitIndex); } } async function handleCompleteVisit(e, estimateId) { const targetButton = e.target.closest('.complete-visit-dashboard-btn'); if (!targetButton || !targetButton.dataset.visitIndex) return; const visitIndex = parseInt(targetButton.dataset.visitIndex, 10); const estimate = allEstimates.find(est => est.id === estimateId); if (!estimate || !estimate.siteVisits || !estimate.siteVisits[visitIndex]) return; ui.openCompleteVisitModal(estimateId, visitIndex, async (note) => { const { db, doc, updateDoc } = window.firebaseServices; const visit = estimate.siteVisits[visitIndex]; visit.completed = true; visit.notes = note; let tags = estimate.tags || []; tags = tags.filter(t => t !== 'Site Visits'); if (!tags.includes('Follow-up')) tags.push('Follow-up'); try { ui.showSuccessBanner("Completing visit...", true); await updateDoc(doc(db, 'estimates', estimateId), { siteVisits: estimate.siteVisits, tags: tags }); estimate.tags = tags; applyDashboardFilter(); ui.showSuccessBanner("Visit completed."); } catch (err) { console.error("Error completing visit:", err); ui.showErrorBanner("Failed to complete visit."); } }); } function applySketchDataToEstimate(sketchId) { const estimateId = document.getElementById('editing-estimate-id').value; if (!estimateId) { ui.showErrorBanner("Cannot apply sketch data: Current estimate ID not found."); return; } const estimate = State.getState().estimates.find(e => e.id === estimateId); if (!estimate || !estimate.sketches) { ui.showErrorBanner("Could not find estimate or sketch data."); return; } const sketch = estimate.sketches.find(s => s.id === sketchId); if (!sketch || !sketch.measurements || sketch.measurements.length === 0) { ui.showErrorBanner("Selected sketch has no measurement data to apply."); return; } const sketchCard = document.getElementById('sketch-card'); if (!sketchCard) { console.error("Could not find sketch pricing card ('#sketch-card') in the DOM."); ui.showErrorBanner("UI Error: Cannot find sketch pricing section."); return; } const container = sketchCard.querySelector('#sketch-items-container'); if (!container) { console.error("Could not find sketch items container ('#sketch-items-container') in the DOM."); ui.showErrorBanner("UI Error: Cannot find sketch items section."); return; } container.innerHTML = ''; sketch.measurements.forEach(item => { if (!item.service || item.service === 'none' || !item.measurement || item.measurement <= 0) { return; } const itemData = { product: item.service, description: item.lineItemDescription || '', units: item.measurement, unitPrice: item.price || 0, color: item.color || '#ccc', sketchItemId: item.id }; ui.addItemToOption('sketch-card', itemData, true, saveState); }); ui.showSuccessBanner('Pricing from sketch has been applied to the Sketch Pricing section.'); ui.calculateAllTotals(saveState); saveState(); } async function handleSketchDelete(sketchId) { if (!confirm("Are you sure you want to permanently delete this sketch? This action cannot be undone.")) { return; } const estimateId = document.getElementById('editing-estimate-id').value; if (!estimateId) { ui.showErrorBanner("Cannot delete sketch: Estimate ID not found."); return; } const { storage, ref, deleteObject, db, doc, updateDoc } = window.firebaseServices; const estimate = State.getState().estimates.find(e => e.id === estimateId); if (!estimate || !estimate.sketches) { ui.showErrorBanner("Could not find estimate or sketch data."); return; } const sketchToDelete = estimate.sketches.find(s => s.id === sketchId); if (!sketchToDelete) { ui.showErrorBanner("Sketch not found within the estimate data."); return; } try { ui.showSuccessBanner("Deleting sketch...", true); if (sketchToDelete.screenshotUrl) { try { await deleteObject(ref(storage, sketchToDelete.screenshotUrl)); } catch (storageError) { if (storageError.code !== 'storage/object-not-found') { throw storageError; } console.warn("Sketch screenshot already deleted or not found in storage:", sketchToDelete.screenshotUrl); } } estimate.sketches = estimate.sketches.filter(s => s.id !== sketchId); State.updateEstimate(estimate); ui.renderSketchesList(estimate.sketches, handleSketchDelete, applySketchDataToEstimate, handleSketchDuplicate); saveState(); ui.showSuccessBanner("Sketch deleted successfully."); } catch (error) { console.error("Error deleting sketch:", error); ui.showErrorBanner(`Could not delete sketch: ${error.message}`); } } async function handleSketchDuplicate(sketchId) { const estimateId = document.getElementById('editing-estimate-id').value; const estimate = allEstimates.find(e => e.id === estimateId); if (!estimate) { ui.showErrorBanner("Could not find estimate data to duplicate sketch."); return; } const sketchToCopy = (estimate.sketches || []).find(s => s.id === sketchId); if (!sketchToCopy) { ui.showErrorBanner("Could not find the original sketch data to copy."); return; } const { db, doc, updateDoc } = window.firebaseServices; ui.showSuccessBanner("Duplicating sketch...", true); try { const newSketch = JSON.parse(JSON.stringify(sketchToCopy)); newSketch.id = `sketch_${Date.now()}`; newSketch.title = `${newSketch.title || 'Sketch'} (Copy)`; delete newSketch.formattedEstimateUrl; newSketch.createdAt = new Date().toISOString(); const updatedSketches = [...(estimate.sketches || []), newSketch]; await updateDoc(doc(db, 'estimates', estimateId), { sketches: updatedSketches, lastSaved: new Date().toISOString() }); estimate.sketches = updatedSketches; estimate.lastSaved = new Date().toISOString(); ui.renderSketches(updatedSketches, applySketchDataToEstimate, handleSketchDelete, handleSketchDuplicate); saveState(); ui.showSuccessBanner("Sketch duplicated successfully."); } catch (error) { console.error("Error duplicating sketch:", error); ui.showErrorBanner(`Could not duplicate sketch: ${error.message}`); } } async function handlePrint() { const saveButton = document.getElementById('save-estimate-button'); let originalButtonText = ''; if (saveButton) { originalButtonText = saveButton.textContent; saveButton.disabled = true; saveButton.textContent = 'Generating...'; } const estimateData = getEstimateDataForSave(); const printableHtml = generatePrintableEstimateHTML(estimateData); const printWindow = window.open('', '_blank'); if (printWindow) { printWindow.document.write('<!DOCTYPE html><html><head><title>Print Estimate</title></head><body>'); printWindow.document.write(printableHtml); printWindow.document.write('</body></html>'); printWindow.document.close(); printWindow.onload = () => { try { printWindow.print(); } catch (e) { console.error("Print failed:", e); printWindow.alert("Could not print automatically. Please use your browser's print function (Ctrl+P or Cmd+P)."); } finally { if (saveButton) { saveButton.disabled = false; saveButton.textContent = originalButtonText; } } }; } else { ui.showErrorBanner("Could not open print window. Please check your pop-up blocker."); if (saveButton) { saveButton.disabled = false; saveButton.textContent = originalButtonText; } } } async function saveTags() { const { db, doc, updateDoc } = window.firebaseServices; const modal = document.getElementById('tag-modal'); if (!modal) return; const estimateId = modal.querySelector('#tag-modal-estimate-id').value; if (!estimateId) { ui.showErrorBanner("Could not determine which estimate to update."); return; } const selectedTags = Array.from(modal.querySelectorAll('#tag-modal-checkboxes input:checked')).map(cb => cb.value); const estimate = allEstimates.find(e => e.id === estimateId); if (!estimate) { ui.showErrorBanner("Could not find estimate data to update."); return; } const nonCategoryTags = (estimate.tags || []).filter(tag => !CATEGORIES.includes(tag)); const newTags = [...nonCategoryTags, ...selectedTags]; try { ui.showSuccessBanner("Saving categories...", true); await updateDoc(doc(db, 'estimates', estimateId), { tags: newTags }); estimate.tags = newTags; if (document.getElementById('editor-view').classList.contains('active') && document.getElementById('editing-estimate-id').value === estimateId) { const tagsContainer = document.getElementById('editor-tags-container'); if (tagsContainer) { ui.renderTags(newTags, tagsContainer); } } if (document.getElementById('dashboard-view').classList.contains('active')) { applyDashboardFilter(); } saveState(); ui.showSuccessBanner("Categories updated successfully."); modal.classList.add('hidden'); } catch (error) { console.error("Error saving tags:", error); ui.showErrorBanner("Could not update categories."); } } async function batchUpdateCategory() { const { db, writeBatch, doc } = window.firebaseServices; const modal = document.getElementById('category-modal'); if (!modal) return; const idsString = modal.querySelector('#category-modal-ids').value; const ids = idsString ? idsString.split(',') : []; if (ids.length === 0) { ui.showErrorBanner("No estimates were selected for category update."); return; } const selectedCategories = Array.from(modal.querySelectorAll('#category-modal-options input:checked')).map(cb => cb.value); const batch = writeBatch(db); ids.forEach(id => { const estimate = allEstimates.find(e => e.id === id); if (estimate) { const nonCategoryTags = (estimate.tags || []).filter(tag => !CATEGORIES.includes(tag)); const newTags = [...nonCategoryTags, ...selectedCategories]; const estimateRef = doc(db, 'estimates', id); batch.update(estimateRef, { tags: newTags }); } else { console.warn(`Could not find estimate data for ID: ${id} during batch update.`); } }); try { ui.showSuccessBanner(`Updating categories for ${ids.length} items...`, true); await batch.commit(); ids.forEach(id => { const estimate = allEstimates.find(e => e.id === id); if (estimate) { const nonCategoryTags = (estimate.tags || []).filter(tag => !CATEGORIES.includes(tag)); estimate.tags = [...nonCategoryTags, ...selectedCategories]; } }); if (document.getElementById('dashboard-view').classList.contains('active')) { applyDashboardFilter(); } ui.showSuccessBanner(`${ids.length} items updated successfully.`); modal.classList.add('hidden'); } catch (error) { console.error("Error performing batch category update:", error); ui.showErrorBanner(`Failed to update categories: ${error.message}`); } } async function planRoute() { const selectedIds = getSelectedIds(); const routeLinkContainer = document.getElementById('route-link-container'); if (routeLinkContainer) routeLinkContainer.innerHTML = ''; if (selectedIds.length < 2) { ui.showErrorBanner("Please select at least two estimates with addresses to plan a route."); return; } let startPointId = null; const startPointCheckbox = document.querySelector('.start-point-checkbox:checked'); if (startPointCheckbox) { startPointId = startPointCheckbox.dataset.id; } const locations = selectedIds.map(id => { const est = allEstimates.find(e => e.id === id); const address = est?.customerInfo?.siteAddress || est?.customerInfo?.address; return address ? { id: id, address: address } : null; }).filter(Boolean); if (locations.length < 2) { ui.showErrorBanner("Fewer than two selected estimates have a valid address."); return; } let originLocation; let remainingLocations = [...locations]; if (startPointId) { const startIndex = remainingLocations.findIndex(loc => loc.id === startPointId); if (startIndex > -1) { originLocation = remainingLocations.splice(startIndex, 1)[0]; } } if (!originLocation) { originLocation = remainingLocations.shift(); } const destinationLocation = remainingLocations.pop() || originLocation; const waypoints = remainingLocations.map(loc => loc.address).join('|'); const mapsUrl = `https: if (routeLinkContainer) { routeLinkContainer.innerHTML = `<a href="${mapsUrl}" target="_blank" class="text-blue-300 hover:underline text-sm font-medium">Open Planned Route in Google Maps</a>`; ui.showSuccessBanner("Route link generated below."); } else { window.open(mapsUrl, '_blank'); } } function getSelectedIds() { const checkedBoxes = document.querySelectorAll('#estimate-list-container .item-select-checkbox:checked'); const ids = Array.from(checkedBoxes).map(checkbox => checkbox.dataset.id); return ids; } function copyDynamicOption(currentCard, saveState) { console.log("copyDynamicOption function called for card:", currentCard); if (!currentCard) { ui.showErrorBanner("Could not identify the option card to copy."); console.error("copyDynamicOption failed: currentCard is null or undefined."); return; } console.log(`Attempting to get data directly from card element with ID: ${currentCard.id}`); const optionData = getOptionData(currentCard, ui.getQuillInstance()); if (!optionData) { ui.showErrorBanner("Could not retrieve data for the option to copy."); console.error(`copyDynamicOption failed: getOptionData returned null for card element ID: ${currentCard.id}`); return; } console.log("Original option data retrieved:", JSON.stringify(optionData)); try { const newOptionData = JSON.parse(JSON.stringify(optionData)); newOptionData.id = `option-${Date.now()}`; console.log("Generated new option ID:", newOptionData.id); newOptionData.title = `${newOptionData.title || 'Option'} (Copy)`; console.log("Calling ui.addPricingOption with new data:", JSON.stringify(newOptionData)); ui.addPricingOption(newOptionData, saveState); ui.showSuccessBanner("Option copied successfully."); console.log("Option copy process seems successful. Saving state."); saveState(); } catch (error) { console.error("Error during copyDynamicOption execution:", error); ui.showErrorBanner(`Error copying option: ${error.message}`); } } async function saveContentToEstimate(contentType) { const estimateId = document.getElementById('editing-estimate-id').value; if (!estimateId) { ui.showErrorBanner("Please save the estimate before saving content."); return; } const { db, doc, updateDoc } = window.firebaseServices; let editorKey, fieldName; if (contentType === 'appendix') { editorKey = 'appendix'; fieldName = 'appendixContent'; } else if (contentType === 'terms') { editorKey = 'terms'; fieldName = 'terms'; } else { return; } const quill = ui.getQuillInstance(editorKey); if (!quill) return; const content = quill.root.innerHTML; try { ui.showSuccessBanner("Saving content...", true); await updateDoc(doc(db, 'estimates', estimateId), { [fieldName]: content, lastSaved: new Date().toISOString() }); const estimate = State.getState().estimates.find(e => e.id === estimateId); if (estimate) { estimate[fieldName] = content; estimate.lastSaved = new Date().toISOString(); State.updateEstimate(estimate); } ui.showSuccessBanner("Content saved to this estimate."); } catch (error) { console.error("Error saving content:", error); ui.showErrorBanner("Failed to save content."); } } async function saveContentAsDefault(contentType) { const { db, doc, setDoc, getDoc } = window.firebaseServices; let editorKey, docId; if (contentType === 'appendix') { editorKey = 'appendix'; docId = 'default_appendix'; } else if (contentType === 'terms') { editorKey = 'terms'; docId = 'default_terms'; } else { return; } const quill = ui.getQuillInstance(editorKey); if (!quill) return; const content = quill.root.innerHTML; try { ui.showSuccessBanner("Saving as default...", true); await setDoc(doc(db, 'settings', docId), { content: content, updatedAt: new Date().toISOString() }); ui.showSuccessBanner("Content saved as new default."); } catch (error) { console.error("Error saving default content:", error); ui.showErrorBanner("Failed to save default content."); } } async function updateAllEstimatesContent(contentType) { const { db, collection, getDocs, updateDoc, doc } = window.firebaseServices; let editorKey, contentName; if (contentType === 'appendix') { editorKey = 'appendix'; contentName = 'Appendix'; } else if (contentType === 'terms') { editorKey = 'terms'; contentName = 'Terms & Conditions'; } else { return; } const quill = ui.getQuillInstance(editorKey); if (!quill) { return ui.showErrorBanner(`Could not find the ${contentName} editor.`); } const newContent = quill.root.innerHTML; if (!newContent || newContent === '<p><br></p>') { return ui.showErrorBanner(`${contentName} editor is empty. Cannot update all estimates with blank content.`); } ui.showSuccessBanner(`Updating ${contentName} for all estimates... This may take a moment.`, true); try { const querySnapshot = await getDocs(collection(db, "estimates")); const estimatesToUpdate = []; querySnapshot.forEach(doc => { const data = doc.data(); if (data.status !== 'Template' && !data.isDeleted) { estimatesToUpdate.push(doc.ref); } }); if (estimatesToUpdate.length === 0) { return ui.showSuccessBanner("No active estimates found to update."); } let successCount = 0; let errorCount = 0; const fieldToUpdate = (contentType === 'appendix') ? 'appendixContent' : 'terms'; for (const docRef of estimatesToUpdate) { try { await updateDoc(docRef, { [fieldToUpdate]: newContent, lastSaved: new Date().toISOString() }); successCount++; const est = State.getState().estimates.find(e => e.id === docRef.id); if (est) { if (contentType === 'appendix') est.appendixContent = newContent; else if (contentType === 'terms') est.terms = newContent; est.lastSaved = new Date().toISOString(); State.updateEstimate(est); } } catch (updateError) { if (updateError.code === 'invalid-argument' || updateError.code === 'resource-exhausted') { console.warn(`SKIPPED: Estimate ${docRef.id} is too large to update.`, updateError.message); errorCount++; } else { throw updateError; } } } await saveContentAsDefault(contentType); if (errorCount > 0) { ui.showErrorBanner(`Updated ${successCount} estimates. ${errorCount} estimate(s) were skipped because they are too large.`); } else { ui.showSuccessBanner(`Successfully updated ${contentName} for ${successCount} estimates.`); } } catch (error) { console.error(`Error updating all ${contentName}:`, error); ui.showErrorBanner(`Failed to update estimates: ${error.message}`); } } function initializeDragAndDrop() { const container = document.getElementById('pricing-options-container'); if (!container) return; let draggingElement = null; container.addEventListener('dragstart', (e) => { draggingElement = e.target.closest('.price-option-card'); if (draggingElement) { setTimeout(() => { draggingElement.classList.add('dragging'); }, 0); } else { e.preventDefault(); } }); container.addEventListener('dragend', () => { if (draggingElement) { draggingElement.classList.remove('dragging'); draggingElement = null; } }); container.addEventListener('dragover', (e) => { e.preventDefault(); if (!draggingElement) return; const afterElement = getDragAfterElement(container, e.clientY); const currentIndicator = container.querySelector('.drag-over'); if (currentIndicator) { currentIndicator.classList.remove('drag-over'); } if (afterElement == null) { container.classList.add('drag-over'); } else { afterElement.classList.add('drag-over'); } }); container.addEventListener('dragleave', (e) => { if (e.target === container) { container.classList.remove('drag-over'); } }); container.addEventListener('drop', (e) => { e.preventDefault(); if (!draggingElement) return; container.classList.remove('drag-over'); container.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over')); const afterElement = getDragAfterElement(container, e.clientY); if (afterElement == null) { container.appendChild(draggingElement); } else { container.insertBefore(draggingElement, afterElement); } ui.calculateAllTotals(saveState); saveState(); }); } function getDragAfterElement(container, y) { const draggableElements = [...container.querySelectorAll('.price-option-card:not(.dragging)')]; return draggableElements.reduce((closest, child) => { const box = child.getBoundingClientRect(); const offset = y - box.top - (box.height / 2); if (offset < 0 && offset > closest.offset) { return { offset: offset, element: child }; } else { return closest; } }, { offset: Number.NEGATIVE_INFINITY }).element; } async function handleStarRatingClick(e) { const btn = e.target.closest('.star-btn'); if (!btn) return; const estimateId = btn.dataset.id; const rating = parseInt(btn.dataset.rating); const { db, doc, updateDoc } = window.firebaseServices; const estimate = allEstimates.find(e => e.id === estimateId); if (estimate) { estimate.leadRating = rating; applyDashboardFilter(); } try { await updateDoc(doc(db, 'estimates', estimateId), { leadRating: rating, lastSaved: new Date().toISOString() }); } catch (err) { console.error("Failed to save rating:", err); } } window.handleAutoCalculateSnowPrice = handleAutoCalculateSnowPrice; window.handleRouteChange = handleRouteChange; window.updateSnowContractSummary = updateSnowContractSummary; Object.defineProperty(window, 'allEstimates', { get: () => State.getState().estimates }); window.ui = ui;